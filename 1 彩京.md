# 第3章、地图的滚动

大家好在上一讲中，我们了解了游戏动画的原理，搭建游戏的基本环境，

这一讲我们讲解如何实现地图的滚动
打开GameStartFrame主窗体类

在上一讲中，我们实现线程的创建和线程的启动。
我们在线程的run方法中书写游戏相关的业务，
由于角色图片需要不断切换，所以应该在run方法中书写循环语句，

我们书写whilex循环，每次循环调用Thread.sleep方法休眠20毫秒。
这也就意味着图片20毫秒切换一次，
捕获异常。

将椅子撞同样可以巡官执行角色，图片切换那么这样的方式，好还是书写威尔出个好呢？我们推荐在威尔中使用变量，这样只需要在程序中江边的值变成假，就可以结束循环，避免书写，我要处见的死循环，那么，什么时候需要将听让变成FALSE呢？在游戏通过的时候，我们需要将游戏限制停止切换到通关窗体在游戏通关失败的时候，我们也需要将游戏线程停止切换到私办船体所以应该将以树状作者公有的静态变量在比的那种可以通过类名点的方式直接访问而无需产生窗体对象。
新建公有的。静态，变量。以上。初始化为真。书写，注释。


不过，大家思考问题，我们也可以创建一个布尔变量isRun初始化为真，书写注释。
将循环条件更改为isRun，通过对isRun变量的控制来控制游戏是否运行，
现在，我们需要在窗体中将地图显示出来

显示方式有两种，
第一种是设置JLabel图片标签，将地图图片显示在标签组件中，但这种方式并不推荐，因为JLabel是GUI组件，里面封装了很多的内容，相当庞大，比较耗费内存资源。
如果所有角色都以JLabel图片标签显示，会很大影响游戏执行的性能。
第二种方式就是通过GUI组件提供的Graphics画笔，将图像绘制在窗体中，这种方式只对图片本身操作，内存耗费比较小。

方法：drawFrame
我们新建绘制窗体图像的方法drawFrame，参数设置为Graphics画笔，形参变量设置为g。
导包Java.awt.Graphics

重写：run
在run方法的循环中，调用drawFrame方法。
实参传递为this.getGraphics()，表示当前窗体中获得的画笔，这样每隔20毫秒就调一次drawFrame方法完成窗体中角色的重新绘制
Graphics中提供了drawImage方法，可以完成窗体中图片的绘制，参数有四个，第一个参数为要绘制的图像，第二个参数为绘制图像的X坐标，第三个参数为绘制图像的Y坐标，第四个为图像绘制的窗体对象，该方法可以将图像以原始大小显示在窗体中。

我们新建属性，地图的Image图像对象，变量名设置为gameMapImage，创建imageIcon对象，参数传递为地图图片路径。
导包,java.awt.Image
在调用getImage()方法得到图像对象。
在drawFrame方法中，调用g.drawImage方法传入地图图像对象。
坐标设置为零和零，表示从窗体的左上角开始绘制，第四个参数设置为this，表示将地图图像绘制在窗体中。

运行一下。
可以看到窗体中已经显示地图最左边的内容。
现在地图是静止的，如果想让地图自动滚动，其实很简单。
我们把绘制地图的X坐标做这一个变量，随着线程不断重绘，改变变量的值，这样就可以不断的绘制地图的其他内容，达到地图滚动的效果，而地图没有y方向变化的需求，我们固定设置为零，
但是如果地图有Y方向变化的需求，那么也需要将地图的Y坐标设置成变量。
我们新建属性，地图的X坐标，变量名设置为mapx，初始化为零。在drawFrame方法中，将mapx累加五个像素。
然后将地图绘制的X坐标更改为变量mapx。运行一下。可以看到地图向右移动。
关于游戏中的坐标是这样设计的，窗体左上角为0到0，越往右X越大，越往下y越大。
所以，我们应该将地图向左移动，这样才能显示地图后面部分，将mapx累减五个像素。

在运行一下。
可以看到地图已经滚动。
不过无论图片在长，也是有限的。我们地图的图片长度为18000像素，那么超过这个范围，地图就无法绘制，就露馅了，将累减的像素更改为50，加快地图移动速度便于测试。

运行一下。
可以看到地图滚动到超过地图图片的长度时，窗体就花了，那么如何在地图到达末尾时自动停下来呢。
考虑到窗体宽度为1000个像素，我们可以加上一个判断。
如果mapx小于等于负的17000像素时，就将mapx赋值为-17000像素。
这样，mapx的值最小就是-17000，地图也就不会再滚动

运行下。
可以看到，地图到达末尾时停止了滚动。
将mapx累减的像素更改为五个像素，这样地图又会以正常速度滚动
地图滚动业务我们已经实现了，
下一讲，我们讲解媒体跟踪器和图像切割。



# 第4章、媒体跟踪器

我们先了解一下什么是媒体跟踪器，在游戏中我们需要绘制各式各样的角色图ga片，地图只是其中一个，但是不同的图片大小是不一样的。地图图片高达3M多，而心形图片只有1K多。
那么很明显，读取地图图片的时间会远远高于读取心形图片的时间，这样造成的结果是心形图片先加载完毕，会先在窗体中显示，而地图图片后加载完毕，后在窗体中显示，这样不同步的后果。
图片显示不同步会影响游戏运行的美观。
解决方案是，采用媒体跟踪器，媒体跟踪器的作用是，将一些图片分成一个组，
在读取时小图片读取完毕后等待大图片读取完毕，然后在一起在窗体中显示，这样可以避免小图片先显示大图片后显示这样不同步的效果。
媒体跟踪器采用MediaTracker实现，在MediaTracker中提供了addImage方法。
该方法有两个参数，一个是图像对象，一个是组号，这样可以将很多图片分成一个组。
另外在MediaTracker中提供的waitForID方法，参数为组号，表示属于该组好的图片，全部加载完毕后在一起显示。
我们在窗体类的构造方法中创建了MediaTracker对象，用变量tracker接收。
传入实参this，表示需要将该窗体中创建的图像进行同步。
调用tracker.addImage方法，添加地图图像gameMapImage，分成1组。
调用tracker.waitForID方法，传入参数1。
表示1组的所有图片等待全部加载完毕后再一起显示。
这样，我们就需要将游戏中所有角色图片都加入1组之后再调用tracker.waitForID方法，就可以保证游戏中的图片同步显示，不会造成图片先显示和后显示这样不同步的效果。


# 第5章、图像切割

这一讲我们讲解如何切割内存图片，我们之前介绍游戏动画原理时提到过，为了减少流操作，我们需要将角色的一个动作做成动作连图，但是显示的时候，同一时间只需要显示其中一张图片，所以我们需要将动作连图读取到内存中以后，再将它在内存中进行切割。
那么如何分割呢？
我们导入一个工具呢，我们导入工具包too.jar，利用工具包中提供了类CutImage完成图像切割，
在CutImage中提供了静态方法cutRowImage，该方法可以通过类名点的方式直接访问，而无需产生CutImage对象，
该方法返回一个Image数组，可以将动作连图切割成一个图像数组，
该方法提供了四个参数，第一个参数为需要切割图片的路径，第二参数为需要将图片切割为几张图片，这个切割是等分切割，也就是要求动作连图中每个动作图片大小一致，第三个参数为媒体跟踪器，第四个参数为媒体跟踪器的分组，这个方法会自动将切割后的图像加入媒体跟踪器指定的组。
在CutImage中还提供了静态方法getSingleImage，方法可以得到单张图片的Image对象，
该方法提供了三个参数，第一个参数为图片的路径，第二个参数为媒体跟踪器，第三个参数为媒体跟踪期的分组，这个方法也会自动将图像加入媒体跟踪器指定的组中。

将tool.jar导入到游戏项目中，放在lib目录下，右键选择添加自构建路径。
我们来切割一下boss动作连图，这是一张18张的动作连图。

在GameStartFrame窗体中新建属性Image数组，数组变量设置为bossImage面积。
这是BOSS图像数组，在创建了媒体跟踪器以后，完成bossImage的初始化，调用cutImage.cutRowImage方法。
第一个参数为切割图片的路径，第二个参数传递为18。表示需要切割成18张图像，而这18张图像就是数组中的元素。第三个参数传入媒体跟踪器对象tracker。第四个参数传入媒体跟踪器的分组1。

我们再来切割一下女孩动作连图，这是一个四张的动作连图。
在GameStartFrame窗体中新建属性Image数组，数组变量设置girlImage，这是女孩的图像数组。
在创建媒体跟踪器以后，完成girlImage的初始化，调用cutImage.cutRowImage方法。
第一个参数为图片路径，第二个参数传递为四，表示需要切割成四张图像，第三个参数传入媒体跟踪器对象tracker，第四个参数传入媒体跟踪器的分组1。
有了cutImage工具类以后。
地图图像产生就可以直接调用cutImage.getSingleImage方法简化开发。
删除属性gameMapImage的初始化，删除加入媒体跟踪器的代码，在媒体跟踪器创建好了以后，完成gameMapImage的初始化，调用CutImage.getSingleImage方法，
传入地图图片路径。传入媒体跟踪器对象tracker。传入媒体跟踪器的分组1。
我们来显示切割后的图片，在绘制了地图以后，调用Graphics画笔的drawImage方法。
传入BOSS图像数组的第一张图片，显示在600*100的位置。

运行一下。
可以看到显示的赵云舞枪的第一张图片，
将下标更改为1，运行下。
显示了赵云舞枪的第二张图片。

不过如果这个图像大小不合适，能不能放大或缩小呢，只需要在Graphics画笔的drawImage方法中添加两个参数就可以了，
drawImage方法中第一个参数为需要绘制的图像。第二参数为会抑制图像的X坐标，第三个参数表示绘制图像的Y坐标吗，第四个参数为需要绘制图像的窗体，这样绘制的图像是原始大小。
不过，这个方法有很多重载方法，只需要添加第四和第五个参数，表示将图像压缩成指定宽度和高度再做显示。
我们将赵云的图像，压缩成100*60。

运行一下。
可以看到赵云的图像缩小了。
再将图像压缩成280*180。

运行一下。
图像又变大了，
不过压缩时需要注意，最好是等比压缩，否则很可能造成图像的畸形，
我们把赵云图像修改为100*400。

运行一下。
可以看到图像已经被挤压得不成样子的。从新将图像修改为280*180。

我们在绘制主角的图像。
调用Graphics.drawImage方法。
传入主角图像数组的第一张图片。显示在100*100的位置，大小压缩成60*40。

运行下，
可以看到显示了主角图像。
在绘制角色时需要注意，先绘制地图再绘制角色。
如果先绘制角色，再绘制地图，很可能地图会把角色覆盖掉
内存图像的切割我们完成了，不过，大家可能发现角色有一些闪烁现象
这个原因是什么呢？又如何解决呢？
我们下一讲讲解双缓冲屏幕外作图来解决这个问题。

# 第6章、双缓冲屏幕外作图

大家好，在上一讲中，我们完成的图像的切割。
不过角色图片绘制时有些闪烁现象，这个原因是什么呢？
我们先来看一下绘制窗体的代码，先绘制地图，然后又在绘制BOSS和女孩。
很显然，在窗体中绘制的角色不止一个，而通过方法调用绘制窗体，每个方法调用执行都会消耗一定的时间，而且不同的角色绘制时，中间可能会夹杂一些算法，所以如果想将所有需要角色图片全部显示在窗体中，那么就会造成因为绘制图片之间的时间差而产生的闪烁现象，极大的影响游戏的美观，那么如何解决游戏图片的闪烁现象呢？

我们需要消除绘制各个角色之间的时间差，我们可以在内存中单独开辟一块内存空间，
专门用于存放需要绘制的图片数据，当我们需要绘制角色图片时，先将角色图片存放在内存空间中，如果还需要绘制别的角色图片时，又叠压在该内存空间中。
这样可以在内存空间中，把所需要在窗体中绘制的图片全部进行叠加，最后形成一幅内存图片，然后再将叠加后形成的内存图片绘制在窗体中。这时由于是一张内存图片，也就没有显示不同角色图片造成的时间差，显示在窗体中时也不会有闪烁现象，

这样的绘制方式称之为双缓冲屏幕外作图。

我们来看一下如何通过双缓冲屏幕外作图解决游戏中的图片闪烁。
首先，新建内存图像属性，属性名设置为memoryImage，用于存放叠加后的图像对象。
再新建内存画笔属性，属性名设置为memoryGraphics，用于在内存图像中绘制需要叠加的图像。

在构造方法中，先对双缓冲图像进行初始化。
调用this.createImage方法，创建内存图像，图像大小应该和窗体大小一致，我们设置为1000*700。
这样就创建了大小为1000*700的内存图像，赋值给memoryImage。
在对双缓冲画笔赋值，调用memoryImage.getGraphics方法得到双缓冲画笔，赋值给this.memoryGraphics属性。

这样，双缓冲画笔绘制的图像就会全部叠加在内存图像中。
打开drawFrame方法，之前我们是直接将图像绘制在窗体中的。
现在，我们将图像绘制在内存图像中，将形参变量g修改为双缓存画笔memoryGraphics，由于绘制的容器不应该是窗体，所以更改为空，表示内存画布中绘制图像。

修改绘制BOSS的方式。
修改绘制女孩的方式。

将所有角色图片绘制在内存图像中。
这样，把需要在窗体中显示的图像都叠加在了内存图像中，最后我们再用窗体本身的画笔g，调用drawImage方法。
传入内存图像memoryImage，这是叠加了众多角色图像之后的内存图像对象，绘制坐标设置为0到0，表示从左上角开始绘制，
绘制的容器传入this，表示将内存中叠加后的图像绘制在窗体中。
需要注意，调用g.drawImage方法将内存图像绘制在窗体中的代码必须是最后一句，否则很可能有些角色不能在窗体中进行绘制。

测试一下。
可以看到，角色图片没有了闪烁效果。
这一讲，我们解决了角色图片的闪烁问题。
下一讲，我们来看一下如何实现角色的动画效果。

# 第7章、角色动画

上一讲中，我们了解了双缓冲屏幕外作图，解决了角色图片在绘制时的闪烁现象，
这一讲我们来实现角色的动画。

动作连图经过CutImage工具类切割之后成为了图像数组。我们需要将这样的一组图像快速进行切换达到动画的目的。
那么很显然，我们在显示图片时不能把图像数组下标做成常量，应该做成变量。
由于drawFrame方法20毫秒调用一次，绘制一次窗体，我们可以让下标20毫秒变化一次。

新建boss图片下标变量bossIndex。
在drawFrame方法中，将bossIndex做一个加加，然后将绘制boss图片的下标更改为bossIndex。
这样每隔20毫秒bossIndex加1，那么绘制的就是图像中的下一张图像，达到动画的目的。

不过Boss图片只有18张，如果一直不停加下去，会导致数组下标越界，从而抛出异常。
一般角色动画都是需要反复切换的，所以我们应该在下标超出数组长度时在从第一张开始切换，在bossIndex加加之后，我们做一个判断。

如果bossIndex大于等于18，那么将bossIndex重新赋值为零，避免图像的下标越界。

运行一下。
可以看到赵云一直不停的舞枪，舞完第一遍后，又在舞第二遍，真是好枪法！
不过舞枪速度比较快，原因是每20毫秒就切换一次图片，速度当然快，那么有什么办法让赵云舞枪的速度慢下来呢？
有人说，大家还不简单吧，把线程切换时间变长一点不就行了嘛。
不过大家想一下，一旦将线程切换时间变长，就意味着重绘窗体时间变长，所有角色切换速度都会变慢，一旦超出人眼的自由时间，那么就会让玩家觉得游戏很卡，而且游戏中有很多角色，有些角色切换的快，有些角色切换的慢，即使同一个角色在不同状态下切换速度可能也不太一样。

比如在植物大战僵尸中有一个寒冰射手，击中敌人后，敌人的速度会变慢，所以修改休眠时间来控制角色切换速度的方式并不可取。我们可以重新建一个计数属性bossCount。在线程中让bossCount做加加。
然后判断bossCount是否大于等于三，如果大于等于三，重新将bossCount赋值为0。
这样，bossCount每隔20毫秒加1，而if判断则是三次以后才执行一次，也就是60毫秒执行一次，我们再将图片下标做一个加1。

如果超出数组下标范围，重新将bossIndex归零，这样就意味着bossIndex变量每隔60毫秒变化一次，那么图像的切换速度也是60毫秒切换一次，达到控制动画速度的目的。

运行一下。
可以看到赵云舞枪的速度已经明显降低。
我们再来完成主角图片的切换，算法和赵云图片切换算法一致。
新建属性girlIndex，用于控制女孩图片下标。在新建女孩图片切换计数器girlCount。
在线程中将girlCount做加加。
如果girlCount大于等于二，重新将girlCount赋值为0，这就意味着女孩图片是40毫秒切换一次。
然后将girlIndex女孩图片下标加加，由于女孩图片数组是四张图片，那么判断girlIndex大于等于4的时候重新将girlIndex赋值为0。将绘制女孩图片的下标修改为girlIndex。

运行一下。
可以看到发着金光的女孩显示出来了。
这一讲我完成游戏角色动画，下一讲我们来看一下如何通过键盘控制主角的移动。

# 第8章、控制主角移动

这一讲我们通过键盘控制主角的移动。
首先我们来看一下如何添加键盘监听事件，在GUI事件中有一个键盘监听接口KeyListener，实现该接口，并通过调用事件源的addKeyListener方法注册键盘事件，在KeyListener接口中提供了三个方法交给开发者书写相关的业务操作。
KeyPressed方法在按下键盘时触发，
KeyReleased方法在弹起键盘时触发，
KeyTyped方法在键入某个键时触发，我们重点关注KeyPressed键盘按下方法和KeyReleased键盘弹起方法。

将GameStartFrame实现键盘监听接口KeyListener。
实现接口中定义的方法。
在窗体的构造方法中，完成窗体键盘事件的注册。调用this.addKeyListener方法，这里的this，表示窗体事件源，由于当前窗体同时也是监听器，所以传入键盘事件监听器this。

这样，当窗体中有键盘事件发生，就会调用窗体中相关的键盘事件方法。
我们先测试一下，在KeyPressed方法中打印“按下”。在KeyReleased方法中打印“弹起”。

运行一下。
按下键盘，可以看到不断的打印按下。
松开键盘，打印了一次“弹起”，键盘事件成功添加。

现在我们需要让主角移动起来，那么我们需要通过键盘事件改变主角的坐标，从而达到控制主角移动的目的。
先将主角的坐标设置为属性。
创建gitlX变量，表示主角的X坐标，初始值设置为100。
创建girlY属性，表示主角的Y坐标，初始值设置为100。

绘制主角图像时将两个常量修改girlX和girlY，这样通过改变girlX和girlY的值改变绘制图像坐标达到控制主角移动的效果。
我们在KeyPressed键盘按下事件中将girlX累加五个像素，表示按下键盘后，主角可以持续向右移动五个像素

运行下。
按一下键盘，可以看到主角向右移动，不过这里有个问题，那就是无论按下了什么键，主角都会向右移动，更何况，我们希望主角通过键盘控制，可以向上向下向左向右移动，

那么能不能再按下某个特定键以后才让主角移动呢？
在KeyPressed方法中有一个形参KeyEvent，这是键盘事件的事件对象，通过KeyEvent的getKeyCode的方法可以得到键盘事件的键盘码。
另外，在KeyEvent中提供了很多以VK_下划线开始的常量，当键盘事件键盘码和这些常量匹配时，表示用户按下或弹起了该键。

比如VK_下划线0到9，表示用户按下数字键，
VK_下划线A，表示用户按下键盘A键，
VK_下划线DOWN，表示用户按下向下键，
VK_下划线ENTER，他表示用户按下的回车键等等，
所以我们在键盘按下事件方法中。先通过事件对象调用getKeyCode方法得到键盘码，用变量code接收，
判断code是否匹配KeyEvent的VK_下划线UP，向上常量，如果匹配，表示玩家按下的向上键，将girlY累减五个像素。
判断code是否匹配KeyEvent的VK_DOWN，向下常量，如果匹配，表示玩家按下的向下键，将girlY累加五个像素。
判断code是否匹配KeyEvent的VK_LEFT，向左常量，如果匹配，表示玩家按下的向左键，将girlX累减五个像素。
判断code是否匹配KeyEvent的VK_RIGHT，向左常量，如果匹配，表示玩家按下的向右键，将girlX累加五个像素。

运行以下
可以看到角色已经能够通过键盘的上下左右键完成移动操作了。
不过移动的动作显得有些生涩，在游戏中还有一种组合件。
比如，当我们同时按下右键和上键时，可以让主角向右上移动，
同时按下左键和下键时，可以让主角向左下移动，
我们来看一下能不能实现，同时下右键和上键。
可以看到只能向右或向上移动，同时按下向左和向下键，可以看到只能向左或向下移动，原因是什么呢？下一讲我们来解决这个问题。

# 第9章、通过组合键控制主角移动

上一讲完整成了通过键盘控制主角的移动，
这一讲我们来看一下如何利用组合件让主角实现斜向移动，
我们先来看一下，在现在的代码中为什么不能实现斜向运动。
我们在KeyPressed方法中输出键盘码code的值。

运行一下。
按下右键，不断打印39，同时按下上键，不断的打印38，
不过我们现在并没有松开右键，为什么39不在打印了呢？
原因是，在键盘事件中同一时间只能响应一个键的事件，这意味着后按下键的键盘板会将前面按下键的键盘码给覆盖掉，那么以后的键盘事件就只会响应后按下键的键盘事件，这就是键盘冲突造成的结果。
但是在开发中很多时候需要我们能同时对多个键盘进行事件的响应，能让主角斜向移动，只是其中一个需求。
当主角发射子弹时也需要通过键盘发射。
这意味着由于有键盘冲突存在，主角发射子弹时必须停下来，发射子弹后需要重新按下方渐渐才能移动。
也就是说，主角不能在移动中发射子弹。
这样给玩家的感觉相当不好，那么如何解决键盘冲突问题呢，显然单单靠事件的处理是无法解决的。

我们可以新建四个布尔属性，
isUp表示用户是否按下向上键，
isDown表示用户是否按下向下键
isLeft表示用户是否按下向左键
isRight表示用户是否按下向右键

在KeyPressed键盘按下事件方法中并不对girlX和girlY直接赋值，而是在用户按下上键键时将isUp赋值为真，
在用户按下下键键时将isDown赋值为真，
在用户按下左键键时将isLeft赋值为真，
在用户按下右键键时将isRight赋值为真，

同时在KeyReleased弹起事件方法中得到键盘码，用变量code接收。
在用户弹起向上键时，将isUp赋值为假，
在用户弹起向下键时，将isDown赋值为假，
在用户弹起向左键时，将isLeft赋值为假，
在用户弹起向右键时，将isRight赋值为假，

这样，我们只需要判断四个布尔值是真还是假，就可以知道用户是否按下方向键，这样的方式好处是可以进行组合键的响应。
比如，用户按一下右键，那么isRight赋值为真，
如果这时用户同时按下了上键，那么isUp变成真，
不过这时用户并没有松开右键，所以isRight、isUp同时为真，只有用户松开键盘之后，才会将四个布尔值重新赋值为假。

这样，我们就可以根据四个布尔变量是真还是假做出组合间的判断。
我们drawFrame方法中，根据四个布尔值来改变主角的坐标。
判断isUp是否为真，如果为真，那么girlY累减五个像素，
判断isDown是否为真，如果为真，那么girlY累加五个像素，
判断isLeft是否为真，如果为真，那么girlX累减五个像素，
判断isRight是否为真，如果为真，那么girlX累加五个像素，

运行一下。
可以看到主角移动相当灵活。而且，也能够同时响应多个键，完成斜上斜下的移动。

# 第10章、碰撞算法

我们来实现角色的碰撞，碰撞算法是游戏中很常见的算法。
比如，我们要判断主角发射的子弹是否击中敌人，就需要判断主角发射子弹是否和敌人相碰，
我们需要判断敌人发射子弹是否击中主角，就需要判断敌人发射子弹是否和主角相碰，
还有主角是否捡到道具，需要判断主角是否和道具相碰，
主角是否能够前进，需要判断主角是否和障碍物相碰等等。

可以说游戏中就是通过碰撞来完成一系列事件的，那么如何判断两个角色是否将碰呢，
很显然，除了要判断两个角色的坐标之外，还判断两个角色的大小，算法比较烦琐，
不过在JAVA API中提供了一个类Rectangle。
该类可以定义坐标空间中的一个区域，通过坐标空间中的位置和大小可以定义这个区域，
该类提供的一个方法intersects，该方法参数是另一个区域对象Rectangle，返回布尔值，
用于判断当前区域和形参区域对象是否相交，

有了Rectangle类和intersects方法后，碰撞算法就可以不用我们写了，
所以平时多看一下API，多看方法，就可以省去我们很多算法的编写。

那么如何实现两个角色的碰撞判断？
我们可以让一块区域和一个角色进行重合，另一块区域和另一个角色重合，然后调用intersects方法判断两块区域是否相交，从而判断角色是否相交。

我们新建一个Rectangle属性，bossRect，表示BOSS赵云的碰撞区域，
导包，java.awt.Rectangle
坐标设置为600*100，大小设置为280*180。
也就是让碰撞区域和赵云重合。

再新建一个Rectangle属性，girlRect，表示主角女孩的碰撞区域，
坐标设置为100*100，大小设置为60*40。
让碰撞区域和女孩重合。

为了看到碰撞区域，我们把碰撞区域画出来，调用memoryGraphics.drawRect方法，绘制Boss赵云的碰撞区域坐标，大小和BOSS RIGHT1致。
在绘制女孩的碰撞区域，坐标和大小和girlRect一致。

运行一下。
可以看到女孩和boss都被一个框给围住，这就是碰撞区域，
不过角色是随时会移动的。
当主角移动时，碰撞区域却还在原地，我们应该将角色和碰撞区域随时重合，才能根据碰撞去判断角色是否相碰。
在drawFrame方法中，
将girlRect的X坐标赋值为女孩的X坐标，girlX
将girlRect的Y坐标赋值为女孩的Y坐标，girlY

运行一下。
可以看到，碰撞区域已经随着主角在移动，那么如何判断女孩和BOSS相交呢？
我们在控制台打印
girlRect.intersects(BossRect)，测试两块区域是否相交
运行一下。
可以看到刚开始为假，移动主角和BOSS相碰，可以看到打印了真，在离开又变成假，这样我们可以给每个角色都分配一个碰撞区域，通过调用intersects方法完成碰撞的判断。

# 第11章、单一职责原则重构项目

大家好，在上一讲中，我们完成碰撞算法，游戏基础知识讲解完毕。

不过随着游戏角色的增多，角色动作了增多，游戏功能的增加
游戏主窗体类代码成爆炸式的急剧增加，这样开发下去，会导致开发者无所适从，
代码越写越多，越写越乱，最终导致项目失败
如何对项目进行合理的组织和管理，让项目开发有条不紊地进行下去呢？

众多开发者在经历一系列的项目开发以后总结出了一些设计原则以及设计的模式。
这些设计的原则以及设计的模式是具有代表性的重复性问题以及解答方案，
我们可以将这些设计原则和设计模式应用到不同的项目环境中去
解决一些项目中遇到的一系列问题

设计原则总纲，是解决问题的思路，而设计模式则是设计原则的具体体现，
所以要用好设计模式，我们首先需要掌握设计原则，那么对于这个游戏项目，
我们应该如何应用设计原则和设计模式优化呢，

### 问题：单一职责原则

首先我们看一下，第一个设计原则，
单一职责原则，单一职责原则是这样滴，
对一个类而言，应该仅有一个引起他变化原因，永远不要让一个类存在多个改变的理由，
换句话说，一个类只应该做和一个职责相关的业务，不应该把过多的职责，放在一个类中完成。

这句话如果理解呢，就好比一个公司，只要老板一个人，那么决策是它、生产是他、销售是他、售后也是他、那么他会非常忙碌，很可的一边写材料，一边打电话联系客户，造成的结果是，不但对老板的要求会很高，公司业务必须全部要熟悉，而且这样的公司生产能力低下，客户少，业务也不会扩大。老板最终会过劳死
解决方案是老板招收一批员工，一部分专门管生产、一部分专门管销售，一部分专门做售后，而老板主要是决策和管理。
这样，每个员工职责单一，以后员工只需要关注自己分类的事情，关注点就会从公司这个整体变成局部的一个点，这样，不但对员工的要求会降低，而且可以提高员工的工作效率公司，每个员工都有清晰职责划分以后，公司运作会有条不紊。
这就是单一职责带来的好处
生产汽车也是同样道理，做出一量汽车很困难，因为汽车结构复杂，但是把汽车拆成一个一个零件之后，做出单个零件会很容易，
工人不必关心整个的汽车结构，只需要关注零件本身就行了，关注点就从整体变成局部，而且不断的做单一的零件会很快提高熟练度，生产效率会大大提高。

我们的看一下GameStartFrame这个类。
如果我们需要修改窗体相关的信息，需要修改GameStartFrame这个类。
如果我们需要修改线程相关的信息，也需要修改GameStartFrame这个类。
如果我们需要修改地图相关的动作，需要修改女孩的动作，以及boss的动作，那么这个类需要频繁修改。
所以。我们这个类拥有众多需要修改的理由，也拥有了众多的职责，所以这个类违反了单一职责原则。解决方案就是按照单一职责原则，把众多的职责划分出去。

### 新建类：GameMap

首先，我们新建一个类GameMap，包名书写为role。
把地图相关的业务书写在该类中。
先移动地图相关的属性

地图的图像gameMapImage，
地图的X坐标mapx，
对于地图的滚动算法，这是地图的行为。
所以我们创建方法绘制地图，图片创建作买私钥和方法。
绘制地图自身图片，把地图滚动算法移动当该方法中。

这里有些错误，首先绘制图片是需要双缓冲画笔，
我们在drawMyself方法中定义行参变量，Graphics。
导入java.awt.Graphics
用形参变量调方法完成地图图像的绘制，然后现在绘制的地图图像是空的，

考虑到游戏角色很多，众多的角色都有大量的图片需要加载，需要切割，需要加入媒体跟踪器的分组，
所以我们最好创建一个类专门完成图像的加载和切割以及对媒体跟踪器的管理，

### 新建类：InitImage

新建一个类InitImage，包名书写为util，这是一个工具类。
专门用于初始化和切割图像。

### 方法：init ---  InitImage

创建静态方法init，这样类名点的方式可以直接访问该方法，
在init方法中定义窗体形参变量JFrame。
创建媒体跟踪器对象MediaTracker，传入形参frame，
这里有编译错误，原因是在INT尾卖一中并没有BOSS跟以班级以及用漫步一班级，这几个变量，
现在我们需要完成对漫步中给MAP100G属性的初始化，
那么如何在init方法以外访问该属性呢？
考虑到无论我运行几次游戏，地图加载来一次就行了，
没有必要每次游戏都重复读取图片文件，所以可以将mapx做成公共的静态变量。

将在initImage中可以通过给漫步。类名点跟漫步一班级方式访问
该变量在创建的媒体跟踪器以后，
调用CutImage.getSingleImage方法完成对丁漫步中的给漫步尾卖，
给静态变量的初始化B加入媒体跟踪器分组。

### 新建类：boss

我们在创建BOSS类。
将BOSS相关的职责，交给该类实现将BOSS相关的属性移动的该类中
boss图像数组Image[]
boss的图片切换计数器ImageChange
boss的碰撞区域，在定义作买校服方法，传入双缓存画笔。
导包。
将boss图像切换的代码移动到该方法中。

调用双缓冲画笔的做一般的方法完成BOSS图片的绘制。
现在我们需要完成博士一半的属性的初始化。
将BOSS已迈进定义为公共的静态变量在INT你麦去中完成BOSS已迈进图像切割。

好，这一讲，我们完成的地图类初始化、图像类以及boss类职责的抽取，
大家好好理解一下，下一讲，我们在完成其他职责。

# 第12章、单一职责原则重构项目（2）

大家好，在上一讲我们完成地图类初始化、图像类以及boss类职责的抽取
这一讲我们完成其他职责的抽取。

### 新建类：PressKeyEvent

我们现在对键盘事件职责进行抽取，
在util包中新建键盘事件处理类PressKeyEvent，继承键盘事件监听接口KeyListener，重写接口方法。

将GameStartFrame中创建的用户是否按下向上键、向下键、向左键、向右键四个布尔属性。
移动到PressKeyEvent中，
将键盘事件处理方法，移动到PressKeyEvent中。

考虑到女孩需要根据四个布尔属性来决定一个方式，所以应该将四个布尔属性做成公有的静态变量。
这样，通过类名点的方式可以直接访问这四个布尔属性。

打开。取消。袁某对键盘事件的监听。
在注册键盘事件监听时，注册为普锐斯T。衣服的对象，这样当给原本中有键盘事件发生时由普锐斯K1问他完成对键盘事件的业务进行处理，
这样将响应键盘事件，死者就交给PRICE K1问题的实现
将控制女孩移动方式中访问四个布尔属性的方式更改为PRE S T1问他访问的方式。

### 新建类：Girl

现在对描述女孩相关的职责进行抽取，在role包中新建Girl类。
将女孩相关的属性移动到Girl中，
与还是图像女孩，图片下标你和图片切换计数器与和的X和Y坐标。
移动到与和那种将与和的碰撞区域。也一度当女孩立忠。
将女孩的图像做成公有的静态变量，这样在初始化图像类名点的方式进行访问，

将女孩相关的行为抽取到个类中，在女孩类中。
创建作drawMyself方法，用于抑制女孩相关的图片，以及描述女孩的行为，
传入省三果THIS3环的话比。
好吧。引用妹妹或者是三环画笔绘制，月球图像，
至于抑制女孩和BOSS的碰撞区域，只是测试性代码可以删掉。

现在还有两个职责，关于窗体的和关于线程的,
很显然GameStartFrame 继承于 JFrame应该完成窗体相关的职责。
那么我们应不应该把线程相关的职责分离出来呢，其实可以分也可以不分

### 问题：单一职责的粒度

主要看分的粒度，什么是力度呢，
就好像工地中的河沙一样，河沙有粗有细，
应用单一职责原则，也需要根据职责的大小和应用复杂度来进行职责的抽取
当职责比较简单，业务不复杂时可以让一个类同时拥有两个或多个职责。
如果对职责抽取的过细，反而增加代码复杂度，增加维护成本。

当然，如果职责中业务比较复杂，那么必须进行抽取。
对于GameStartFrame类中线程的作用，
只是为了对窗体中的图像进行不断的绘制，比较简单，
所以可以不做抽取，这样通过一系列的抽取，我们让每个类都有自己固定的职责。

GameMap类完成地图相关的业务。
Boss类完成BOSS相关的业务。
Girl类完成女孩相关的业务。
InitImage类完成图像切割和媒体跟踪器的管理。
PressKeyEvent类完成对键盘事件的业务处理，
这样在开发每个类时我们的关注点就可以从整个游戏项目变成只关注某一个职责，
这么一个点上面，这样可以减少开发难度

好，我们来完成众多职责类相关应用方法调用。
在GameStartFrame类中，新建地图属性。用变量gameMap接收。
新建Boss属性，用变量boss接收。
新建女孩属性，用变量girl接收。

在构造方法中，调用初始化图像对象的init方法，传入this，表示  GameStartFrame对象。
完成图像的切割和媒体跟踪期的管理
需要注意初始化图像以后再启动绘制窗体的线程，否则很可能造成空指针异常。

在drawFrame方法中完成地图对象做吗？
CF方法的调用，并传入双缓冲画笔。
在调用BOSS的drawMyselg方法完成BOSS相关的业务。
在调用与还得做嘛，幸福方法完成女孩相关的业务运行一下。
效果是一样的。不过，将职责分担给各个以后可以让开发有条不紊地进行下去，

如果需要修改某一个角色和某一个功能只需要修改和这个角色这个功能相关的类就可以了。
如果需要新增角色，也只需要新增和该角色相关的角色类就可以了。

### 问题：重用boss和女孩相同的代码

大家思考一下bossl类和女孩类中有哪些代码是相同的。
这样相处的代码，我们能不能够重用呢。

# 第13章、开闭原则抽取角色的属性

大家好，在上一讲中，我们应用单一职责原则，
将众多的职责，交给了专门处理该职责的类来完成，每个类职责划分以后
只关注本职责范围之类的业务，我们不难发现，在boss类和女孩类中有些代码是相同的。
那么这样相同的代码，我们能不能够抽取出来进行重用呢，如果可以那么又如何进行抽取呢？

### 问题：开闭原则

我们来看一下，第二个设计原则，开闭原则，
开闭原则，实现定义的软件实体应该面向扩展开放，面向修改关闭
开闭原则是设计原则的核心原则。

那么，什么叫做面向扩展开放，面向修改关闭呢，
面向扩展开放，是指模块的行为可以扩展。
当应用的需求改变时可以对模块进行扩展，以满足新的需求，
面向修改关闭是指对怪物行为扩展是不必改动模块的，

那么如何实现开闭原则呢，
实现开闭原则，主要的手段就是抽象
什么是抽象呢？
抽象的含义不的理解为抽象类。
它的意思是把像的东西抽取出来。
如果一旦代码可以在多个方法中进行重复使用，
我们就应该把这一段代码抽取成一个方法，
通过第二种该方法完成代码重用。

比如，我们在打印图形时，
在A方法中打印一排紧靠在打印商行四类的新号
在B方法中打11排多那，符号在打印三厂四类的心态，
这样我们就应该把打印三杠4点新课的代码抽取层，PRINT是大方法。
在A方法和B方法中进行调用就可以实现代码重用。

如果两个类之间有相同的代码，我们也可以抽取到父类和工具类中，
通过继承和聚合组合方式，调用属性和方法，达到代码重用。

比如，有一个人类有一个吗？类！
这两个类都有年龄属性，都有睡觉的行为，
我们就可以把年龄属性和睡觉行为抽取的父类动物类中。
这样，人类和哪类通过继承就可以实现代码重用，这就是像的地方
通常像的代码都是多个方法和多个那种共同的代码，一般是不需要修改的，这就是开闭原则中的闭，

什么是开呢？
很显然，每个方法都会有自己的作用和需要实现的功能，
每个类也会有自己的职责和需要实现的业务。
虽然有些代码可以从用，但是还是有很多代码是不相同的。
这样不相同的代码，是每个方法和每个那种特有的，这就是不见的部分
那么，我们也应该把这样不见的部分抽取出来，便于公认的扩展。

比如，人类和马类都是动物的子类。
可以重用动物类中定义的属性和方法，这就是闭，
但是人类有工作行为，而马类有拉车的行为。
这是不相同的，这样不相同的代码就应该交给子类，做具体实现，这就是开

事实上开闭原则并不是程序中特有的
开闭原则，在生活中也广泛在体现。

比如开会，开始时一个人发言，第二个人发言时就说我同意他的意见，但需要补充一点，
这就是开闭原则的体现，同意我的意见就表示在重用前一个人的发言类容，这就是闭，
补充发言，就表示在前一个的基础之上扩展，这就是开。

在现实生活中，有很多专做加工的企业，
比如同样的面粉，不同的加工企业可以做成不同的产品
包子店可以将面粉做成包子，面包店可以将面粉做成面包，蛋糕店可以将面粉做成蛋糕，
这些加工企业都需要使用面粉这个原料，所以无论是包子、面包、蛋糕本质都是面粉，就是闭，
但在面粉基础之上，不同的商家，可以作出不同的产品，这是功能的扩展，这就是开！

我们的观察一下BOSS类和女孩之间有哪些代码是相同的
哪些代码是不同的，通过前面讲解的游戏，动画原理，
我们知道做游戏，主要就是把各个角色图像绘制在窗体中，
而绘制角色图片时，我们需要指定角色的坐标和大小。
这是每个角色都有的特征。
另外每个角色应该有一个碰撞区域。通过碰撞区域来完成碰撞算法，这也是每个角色都有的特征。
由于boss类和女孩类之间，除了有相同的属性之外，还有相同的行为，
所以我们需要将属性和行为进行抽取，

我们最好抽取成父类，通过对父类的继承达到代码重用。
这就是闭，回到代码中。

### 新建类：BaseRole

新建所有角色父类BaseRole。
把每个角色相同的属性和行为都放在该类中，

先对属性进行抽取。
创建整型属性x，表示角色的X坐标，考虑到该属性需要在子类中进行使用，所以访问修饰符最好设置为protected，这样，只有本包和不同包的子类才能访问该属性
创建整型属性y，表示角色的Y坐标，
创建整型属性width，表示角色的宽度，
创建整型属性height，表示角色的高度，

我们发现属性Y的注释和属性X的注释大部分都是一样的，所以复制一下，再粘贴到Y属性上面。
粘贴到宽度属性的上方，粘贴到高度属性上方。
然后修改Y坐标的注释、修改宽度的注释、修改高度的注释，
大家仔细思考一下，我们刚才的动作，为什么要复制粘贴呢，
其实这也是在进行抽象，我们在复制x属性的注释以后粘贴在Y属性的注释中，
这样相同的文字就可以不用写，就可以做到文字的重用，这就是所谓的闭。

同时Y属性也有不相同的文字，这是不见的部分，我们进行修改，这就是功能的扩展，也就是开，
所以大家最常用的复制粘贴就是满足开闭原则的一种方式，

另外，每个角色都有自己的图像。
虽然每个角色都有自己的动作连图，但是同一时间只能绘制动作连图中的其中一张图像，
所以我们新建Image属性，属性名创建为roleImage，
表示角色当前应该绘制的图像。
每个角色都有碰撞区域，新建一个Rectangel属性rect。
表示角色的碰撞区域
这样不同的角色只需要继承BaseRole这个父类就可以重用这些属性，而不用重复定义

开闭原则，我们可以总结为将“像”的地方抽取出来，避免代码重用，
将不像地方也抽取出来，便于功能的扩展，
这一讲我们应用开闭原则，完成的角色属性的抽取。另外角色中还有很多行为是相同的。
那么这些相同行为如何进抽取呢，

大家可以思考一下，也可以自己去抽取一下
下一讲，我们应用开闭原则完成角色方法的抽取。

# 第14章、开闭原则抽取角色的行为

大家好在上一讲中，我们应用开闭原则完成的角色属性的抽取
这一讲我们应用开闭原则完成角色行为的抽取
我们来看一下BOSS类和女孩类中有哪些行为是相同的，
BaseRole是所有角色的父类，在这里定义了很多可以重用的属性。
但是，这些属性都需要进行初始化，这是所有角色都有的行为，
那么这些属性的初始化代码应该如何传出去呢，
我们可以在BaseRole中定义构造方法完成对子类基本属性的初始化。
由于子类构建时需要调用父类的构造方法，所以就可以直接调用该一个的方法，完成子类继承属性的初始化。

### 构造方法：BaseRole

创建BaseRole构造方法，
形参为X坐标、Y坐标、高度、宽度，至于图像属性是随时在切换，所以应该在普通方法中完成赋值。
而碰撞区域在构造方法中完成初始化，所以不需要在形参中定义。
构造方法生成之后，在其中需要完成角色碰撞区域的初始化。
按照我们之前讲解的碰撞算法，需要将碰撞区域和角色重合，
但这样做很多时候效果不太好，因为很多角色图片有很多白色的区域，
如果让碰撞区域和角色完全重合，那么很可能当子弹在击中敌人的时候，敌人就已经被打死了，
将给玩家的感觉相当不好，所以我们应该将碰撞区域做的小一点，最好是原来的1/4
X坐标是原来的X坐标加上1/4宽度，Y坐标是原来的Y坐标加上1/4高度，
宽度和高度都是原来的一半，
这样在击中敌人以后，给玩家的感觉会真实一点，

在BaseRole的构造方法中，对rect属性进行初始化。
认可的X坐标设置为角色的X坐标加上1/4的宽度。
Y坐标设置为角色的Y坐标，加上1/4高度。
宽度设置为角色宽度的一半
高度设置为角色高度的一半。

这样，通过调用父类构造方法就可以完成子类继承属性的初始化

### 方法：setRect

由于角色要移动，所以碰撞区域应该随着角色移动而移动，这也是角色共同的行为，
创建方法setRect，由该方法设置碰撞区域随角色移动而移动，在该方法中设置的坐标和大小。
该方法应该在线程中进行调用，这样表示碰撞区始终随着角色的移动而移动。
当然，如果子类碰撞去不可是，也可以重写该方法完成具体子类碰撞区域的设置。

### 方法：drawMySelf

另外每个角色都需要绘制图像都有捉麦斯要不方法，
我们可以把绘制角色的方法抽取出来，完成角色当前图像的绘制。
在BaseRole中定义drawMySelf方法，形参设置为Graphics双缓冲画笔，memoryGraphics，
方法中调用drawImage方法完成角色图像的绘制，
绘制的图像设置为当前角色roleImage图像，
坐标设置为当前角色的X和Y坐标，大小设置为当前角色的宽度和当前角色的高度。
绘制的地点设置为空，表示在move中进行绘制，
将相同的行为抽取出来之后，子类可以通过继承的方式重用这些代码，就是闭。

不过boss类中drawMySelf方法和女孩类中的drawMySelf方法，使用时还是有很多不同的部分
BOSS很可能有很多招式，而女孩也有很多自己的招式，
并且玩家可以控制女孩移动，
从这里可以看出不同的角色都有自己不同的移动方式，都有自己不同的行为，
所以我们应该把这些不同的行为交给子类去扩展。
我们在BaseRole中定义抽象方法，用于描述子类特有的行为，并将BaseRole定义为抽象类。
抽象方法应该由每个子类根据自己角色特点分别去实现，达到相同的行为不同的实现方式的效果。
这就是功能的扩展，也就是

开闭原则的设计，无非就是不断的思考什么代码可以重用，什么地方新的扩展
而联合设计，可以让开发四办公被减少开发难度。

我们以后学习的框架，无非就是将可以重用的部分抽取成框架的一种而有开发者在框架基础上，编写自己的业务逻辑操作，
所以我们在以后的开发中都需要多思考如何应用开闭原则，应用抽象去优化代码。
我们把BOSS类继承BaseRole构造方法。

### 重写：move--- Boss

重写move方法，
在构造方法中传入坐标，600*100，传入大小二百八三一百吧，这样形参也不用定义了，
在move方法中完成图片的切换，也就是对属性roleImage赋值。
将绘制boss图片代码修改为对roleImage赋值。
由于付立中的做慢性方法，已经完成的肉鸡卖起来绘制，
所以我们在子类中的move方法中只需要对然后一般你赋值就可以了。
删除做慢性方法，由父类中的drawMyself方法完成角色图片的绘制
删除BOSS的碰撞区域。该属性可以从父类中继承过来。

这样BaseRole每个子类只需要关注每个角色的移动方式就可以了
很多属性和方法都可以从父类中继承过来,

#### 构造方法：Girl

把女孩类也继承BaseRole，
添加构造方法。重写move方法

在构造方法中传入坐标，-100x100，传入大小60*40
删除形参
完成女孩类坐标和大小初始化

重写：move --- Girl

在move方法中。
完成图像切换以及控制女孩移动，
删除drawMyself方法
将绘制女孩的图片更改为对roleImage赋值。

碰撞区域，所以假设移动已经在富力等地的，
所以我们可以删除女孩的坐标，
女孩的碰撞区域也可以从父类中继承过来，
在子类中删除将盖X和格外描述与和做不了属性，修改为，当前女孩的X和Y属性。

现在Boss类和女孩类除了要绘制图片之外，还需要调用move方法完成移动方式的描述。
另外，还需要调用  方法完成碰撞区域跟随角色移动。

运行一下。效果是一样的。
不过，应用开闭原则以后每个子类重复性的代码就不用再描述
代码会减少很多

大家思考一下，Boss类和女孩类都需要进行图片切换，这个行为是不是也应该抽取的父类中呢？

# 第15章、聚合组合复用原则

大家好在上一讲中，我们应用开闭原则完成角色行为的抽取，
不过在女孩类和Boss的中都需要进行图片切换
这个行为应不应该抽取到父类中呢，
我们的看一下第三个设计原则，聚合组合复用原则，

### 问题：聚合组合原则

使用聚合组合原则，实现代码复用，少用继承来实现代码复用，继承是常用的实现代码复用的方式，子类通过继承父类，可以调用父类中的方法和属性，从而达到代码重用的目的。
另外子类除了从父类中继承的代码以外，
还可扩展自身的属性和方法来描述子类特有的特征和行为，
通过继承可以很方便的实现代码的重用和功能的扩展，
不过继承同样有很多缺陷，

我们来看一个例子，
人类在大千世界中不断的认识世界也不断的改造世界，人类曾经梦想在天空中翱翔那么人类如何飞行呢？
鸟类可以飞行，那是因为鸟类有翅膀这个特征才会拥有飞行这个行为。
如果人类像鸟类一样长出翅膀，那么也就可以有飞行的行为了。

封神榜中的雷震子和外国的天使，其实就是人类想在天空中飞行的一种想法，那就是继承鸟这个类。拥有鸟的翅膀和飞行的行为。
那么人类想下海怎么办呢？
于是人类又在想，是要将人类继承与鱼类，拥有鱼的尾巴。
如果人类既想飞行，又想下海，该怎么办呢？
有人说，那还不简单，把人类同时继承鱼类和鸟类不就行了吗？
但是，在Java中，类只能单根继承，
也就是说，一个类只有一个父类，不能同时继承两个类，
所以从这里就可以看出，继承的其中一个缺点，无法通过继承的方式，重用多个类中的代码。
另外，父类的属性方法子类是无条件继承的，
也就是说，不管子类愿不愿意，都必须继承父类所有的属性和方法。
比如，每个人都有自己的父母，如果父母比较富有，那么子女吃得好，穿得好。
如果父母是穷人，那么子女吃不饱，穿不暖，
很显然，所有的人都希望自己是富二代，官二代而不想成为穷二代。
不过每个人都无法选择自己的父母，所以父母的一切子女无条件接受，
同样道理，如果人类继承鸟类，我们希望拥有的是鸟的翅膀和飞行的行为，
但是鸟还有吃虫的行为，还有下蛋的行为，这些是我们不需要拥有的，
不过如果人类继承鸟类的话，那么鸟类中吃虫和下蛋的行为，人类就要无条件接受。
那么如何解决继承这些缺点呢？
荀子在劝学中有这样一段话：驾于马者，飞力组也儿子千里甲州记者非能水也而绝江河君子心扉，一眼鳝鱼甲鱼，物业
就是说人可以骑马，即使这个人跑得不快也可以到达千里之外人可以坐船，即使这个人不会游泳，也可以到达江河的任何位置，君子其实没有太多，特别的地方，只不过善于利用工具而已，这就是所谓的孩子A表示拥有什么，或者使用什么询之间的话指出了解决基准缺陷办法那，就是使用集合组合达到代码的复用。
比如人想上天怎么办呢？可以利用飞机上天人，想下海怎么办呢？可以利用轮船下海，
并不要求人类必须要长出翅膀，人类必须长出鱼尾，
我们可以定义个飞机类。该类拥有飞行的方法
在定义个轮船类，该类拥有游泳的方法，
在人类中，我们可以集合飞机类和轮船类的对象，
人想飞行的时候，可以调用飞机飞行的方法，
人类想下海的时候，可以调用轮船游泳的方法，
人类就可以同时重用飞机类和 轮船类两个类中的代码，
所以通过聚合组合关系，我们可以重用多个类中的代码，
这种解决方案，其实就是告诉我们，与其我们是什么，倒不如我们用什么，也就是用聚合组合去替代继承复用，把一些特征和行为抽取出来形成工具类，然后通过聚合组合，成为当前类的属性，在调用聚合对象的属性的方法达到代码重用。

另外，我们可以选择一个类中是否应该具有某种行为，
从而决定应该具合哪些类不应该具合哪些类，
通过 聚合组合关系，也可以避免继承造成的方法污染问题，
所以说聚合组合具有很强的代码重用性和灵活性，
在游戏中角色很多，有些角色，需要通过动作连图切换完成角色动画，
但是有些角色是不需要完成切换动画的，
比如女孩发射子弹只有一张图片，而道具也只有一张图片，
这些角色是不需要进行切换的。
也就是说图片切换算法只适合一部分角色，所以如果把图片切换算法放在BaseRole父类中就意味着每个子类都会有该行为就会造成方法污染
解决方案是新建工具类，抽取图片切换算法，然后再需要进行图片切换的角色中聚合图片切换算法工具类，从而达到代码重用的目的，也避免没有图片切换算法的角色受到方法污染。

### 新建包：工具类

新建包：util。

### 新建类：ImageChange

新建类：ImageChange。
定义change方法完成图片的切换，形参定义为图片数组ImageArray[]，表示需要对该数组的图片进行切换，
返回类型设置为Image，图像对象，导包，
表示当前应该绘制的图像，

在该类中。
定义切换图片的计数器count。
定义图片下标变量index。
考虑到不同角色图片切换频率不一样，在建一个图片切换频率属性。
创建构造方法完针对属性频率的初始化。

在change方法中，
将计数器count做加加。
当count大于等于频率时将count归零。
再完成图片下标index的加加
在判断当index大于等于图片数组长度imageArray.length时，
数组下标index归零。
避免数组下标越界，返回值书写为imageArray[index]。
返回对应下标的图像，
将通过该方法就可以得到当前应该绘制的图像

### 操作：ImageChange ---- Boss类

在Boss类中定义图片切换计数器对象ImageChange，
用变量changeObj接收，传入图片切换频率3，也就是60毫秒切换一次。
在move方法中删除图片切换算法，调用changeObj.change方法传入BOSS图片数组，并完成对属性roleImage赋值。
这样，在Boss当中，定义的图片下标以及计数器就不用再定义

### 操作：ImageChange --- Girl类

打开女孩类，聚合图片切换算法工具类ImageChange，
用变量changeObj接收，传入图片切换频率2，也就是40毫秒切换一次。
在move方法中删除之前书写的图片切换算法，调用changeObj.change方法，传入女孩图片数组，并完成对属性roleImage赋值。

这样，在女孩类中定义的图片下标，以及女孩图片切换计数器就可以不用定义了。
把图片切换算法抽取出来之后，可以看到代码减少了很多，测试一下。
可以看到效果是一样的。

这一讲，我们完成图片切换算法的抽取，
大家多理解聚合组合复用原则的含义
下一讲我们完成子弹的发射。

# 第16章、发射子弹

我们应用聚合组合原则完成图片切换算法的抽取
这一讲，我们完成子弹的发射

主角需要通过发射子弹完成对敌人的打击，要发射子弹首先需要创建子弹类描述子弹相关的业务。为了完成角色属性和方法重用，我们前面抽取Base Role角色父类，所以我们应该将子弹类继承Base Role完成对属性和方法重用，

新建类：GirlBullet

在role包中新建子弹类GirlBullet，继承BaseRole，添加构造方法，重写move方法。

子弹的图像，在image文件夹中，由于只有一张图片，所以创建公有的静态变量girlBulletImage，用于描述子弹的图像

打开InitImage图片初始化类，在init方法中完成子弹图像初始化。调用CutImage.getSingleImage方法，传入图片路径，传入媒体跟踪器，传入媒体跟踪器的分组1。

打开子弹类，由于只有一张图像，所以不需要做图片切换算法，我们在构造方法中直接完成对属性roleImage的赋值，赋值girlBulletImage，一父类中的做卖事业部方法，完成对子弹图片的位置，删除构造方法中形参的定义，子弹是女孩发出的，所以子弹的初始化坐标应该是女孩的坐标。

不过我们怎么访问女孩对象呢？我们可以把GameStartFrame中定义的女孩变量girl修改为公共的静态变量。这样，在子弹类中可以通过GameStartFrame.girl的方式访问到游戏中的女孩儿对象。

子弹的初始化坐标设置为GameStartFrame.girl.x，访问到女孩对象在点X的坐标作为子弹的X坐标，女孩的Y坐标作为子弹初始化的Y坐标，为了美观一点，我们将子弹的起始位置定义为女孩位置的右下角，将子弹产生的X坐标设置为女孩坐标加上10个像素，将产生子弹的Y坐标设置为女孩Y坐标加上10个像素，子弹的宽度设置为65，高度设置为15。

通过构造方法完成的子弹属性的初始化，

在move方法中描述子弹的行为，子弹的行为很简单，从右到左移动，this.x属性累加15个像素。

子弹类书写完成，是不是很简单。简单的原因是很多属性和方法，已经在BaseRole父类中得到实现，子类只需要描述不同的部分就可以了。

现在我们需要创建子弹对象，并在GameStartFrame线程中完成子弹的绘制。由于女孩会发出很多子弹，所以我们应该创建一个子弹集合，用于存放发射的子弹对象，然后在线程中调用集合中子弹对象的业务方法，考虑到子弹对象是要通过键盘事件产生，所以应该将子弹集合做成公有的静态变量，方便在键盘事件处理的一种访问

创建公有的静态变量List,泛型书写为BaseRole，变量名命名为roleList。

在卓夫人们方法中遍历子弹集合书写FOR循环。INT I等于0I小于波莱特List点，SIZE I加加在循环体中美循环一次取出一个子但对象，用变量波利特接收。调用宝莱特的做MYSELF方法完成子弹图像的绘制传入双环出画笔，调用子弹对象的木方法，完成子弹移动的描述，调用波利特的SET方法完成子弹碰撞区的一栋

 

打开键盘事件处理类，定义按下A键以后发射子弹，在键盘按下事件中判断键盘是否匹配A键。如果匹配A键，访问GameStartFrame中的子弹集合，然后添加子弹对象。

这样按下一次A键产生一个子弹对象，按下多次A件可以产生很多子弹对象，然后由FRAME中，通过对子弹集合的遍历，完成子弹的绘制

运行一下。

按下A键，可以看到子弹发射出来，不过，这里有个问题，就是如果按住A键不放，会发出一串子弹很不美观。而且发射子弹时，如果主角在移动，由于键盘冲突的问题会让子弹发射终止，如何解决这个问题呢，其实很简单，我们可以把发射子弹的业务操作移动到键盘弹起事件中。这样，如果需要发射子弹就要求玩家必须不断地按下键盘不断地弹起键盘，由于按下键盘和弹起键盘之间有一个时间差，所以可以让子弹发射频率不至于过快，也可以避免键盘冲突，发射子弹时同样可以移动主角，而且不断的按下键盘不断地弹起键盘，可以增加玩家打游戏的快感，街机游戏就是这样设计的。

在运行一下。

可以看到只有不断地弹起键盘才能发射子弹，这样的方式显得很自然。

这一讲，我们完成子弹的发射，不过在游戏中有很多角色，而且很多角色也会创建很多对象，那么这就意味着在SPRING当中，我们除了子弹集合以外，还需要创建很多角色集合。比如花瓣集合道具，集合顶子弹集合，还有众多怪物集合等等。这些代码应该如何优化呢？

# 第17章、依赖倒置原则

大家好，在上一讲中，我们完成的子弹的发射，不过在游戏中有很多角色，而且很多角色也会创建很多对象，那么这就意味着在 GameStartFrame中我们除了子弹集合以外，还需要创建很多角色集合，比如花瓣集合道具集合，敌人子弹集合，还有众多怪物的集合，这段代码应该如何优化呢？

问题：依赖倒置原则

我们看一下第四个设计原则，依赖倒置原则，依赖倒置原则是这样描述的，高层模块不应该依赖于低层模块，两者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。

对于依赖倒置原则，简单的理解就是面向抽象编程，不要面向具体编程。

类与类之间的依赖关系可以分为两种类型，具体耦合关系发生在两个具体可实例化类之间，仅有一个类对另一个具体类直接饮用造成，抽象耦合关系发生在一个具体的类和一个抽象类和接口之间，

我们来举个例子来看一下什么是依赖倒置原则。

白马非马

就是嗯多个禁止入关的方法而参数则是摆满蝗蝻黑马，这样具体的类。这就是面向具体的类进行编程，也就是两个类之间有具体的耦合，这样的定义相当繁琐，怎么办呢？摆满皇马黑马都是吗的子类，所以污染让告示更加具有通用性就应该将吗这个？抽象的类作为参数，而凡是能被被这个形参变量所引用的对象都不能入关，所以食用抽象的父类作为方法参数可以大大增加代码灵活性。

这就是面向抽象编程的方式，也就是两个类之间的耦合关系。抽象耦合有一个很经典的理论，不管是白猫还是黑猫，只要能抓住老鼠就是好猫，从这段话可以看出，我们关注的只是抓老鼠这个行为，而用什么抓只是一个过程，一个手段而已，但是，抓老鼠一定要用猫吗？老鼠药，粘鼠板，老鼠夹子都具有抓老鼠的行为。我们要灭鼠就可以定义多个存在方法，而参数可以是白猫，黑猫，老鼠药等等。这就是面向具体编程，视具体偶可降低相当繁琐，而且不具有可替换性，所以我们应该把众多具有灭鼠行为的类抽取成一个抓老鼠的接口，在人类中定义一个灭鼠的方法，参数就是抓老鼠的接口变量。

这样，只要是该接口的实现类对象都可以传入，因为人在灭鼠的时候，用的工具只会关心他是否具有抓老鼠的行为，而不会关注是什么具体的工具，所以使用接口作为方法参数，也可以大大增加代码灵活性，这也是面向抽象编程，也是抽象耦合，这就是多态参数。这样，人类在灭鼠的时候，只关心灭鼠工具，是否具有灭鼠的行为，不会关注灭鼠工具是如何灭鼠的，这就是高层模块不依赖于底层模块，子集在于抽象类和接口，但是在具体实现白猫，黑猫，老鼠药时，却需要关注接口中定义的实现方法，这就是细节需要依赖于抽象，

依赖倒置原则意义呢？就是多态的思想，当类之间需要进行交互私人尽量使用接口类型和父类类型完成对变量的定义，从而增加代码的灵活性，而不要使用具体的类名来定义。必然类型也就是尽量使用抽象耦合去替代具体偶合，所以我们在以后学习众多的框架和众多的容器是很少看到类基本上都是通过接口和抽象父类完成框架和开发者业务的之间耦合的高类聚DO和是所有优秀软件的共同特征，

高类聚指的就是单一职责原则。一个类一个职责，月单一类聚DO越高，DO和指的就是依赖倒置原则，尽量使用抽象耦合去替代具体耦合。

在游戏项目中，我们定义的子弹集合在集合泛型中一定是子弹类型。这是一个具体的类，那么这就意味着该集合中只能存放子弹对象。如果要描述众多的花瓣，有需要定义花瓣集合，在该集合中自然存放花瓣对象。如果要描述众多的道具，定义道具集合，在该集合中也只能存放道具对象，那么这就意味着有十种角色就得定义十种角色对应的集合，这就是具体耦合的缺点，不过所有的角色都是BaseRole子类，所以按照依赖倒置原则，我们只需要定义一个角色集合，用BaseRole作为集合类型，

这样就意味着在集合中在几个中定义的都是BaseRole变量，按照多态的定义，可以引用任何一个子类对象，所以在该集合中可以存放任何角色，这就是多态应用中的多态集合，也属于抽象耦合。

 

属性：角色集合 ---- GameStartFrame

将子弹集合的泛型类型修改为BaseRole，变量名修改为roleList。

 

方法：keyReleased  ---- PressKeyEvent

打开键盘事件处理类访问角色集合。

由于子弹是BaseRole的子类，所以可以roleList中添加子弹对象。同样道理，BOSS和女孩都是BaseRole的子类，所以在构造方法中同样可以将女孩对象和Boss对象加入roleList。这样在角色集合中就存放了多种角色对象。

 

方法：drawFrame  ---- GameStartFrame

而在drawFrame方法中，对于众多角色方法的调用也可以通过循环的方式进行，在drawFrame方法中删除女孩、BOSS和子弹方法的调用，遍历List角色集合，每循环一次，取出一个元素。

用BaseRole类型的变量role来接收集合元素，相当于用变量引用集合中具体的角色对象，包括子弹、女孩、BOSS，调用角色role的drawMyself方法传入双缓冲画笔，完成角色图片的绘制调。

用角色对象的move方法完成角色的移动，在调用角色的SET方法完成碰撞区的移动这样，我们对游戏的制作就变成对角色集合roleList的管理，添加一个角色，就是在roleList中添加一个角色对象，打死一个怪物就是在roleList角色集合中删除一个怪物对象。这就是多态集合的应用。

还有一点，需要说明一下很多初学者不明白，抽象方法作用是什么，抽象方法没有具体的一种职业方法定义，很显然抽象方法是无法重置的，那么定义抽象方法的意义在什么地方呢？其实主要意义有两个，一、规范子类代码，要求子类必须实现该抽象方法，二、在于多态调用，在多态调用中父类变量引用的对象只能调用父类中定义的属性和方法，不能调用子类特有的属性和方法，所以尽管抽象方法没有具体的一种，但是，他还是一个方法定义，在使用多态时同样可以由父类变量和子类变量所调用。

如果抽象父类或接口中不定义抽象方法，那么使用多态无法调用子类特有的方法。
如果BaseRole中无定义move这个抽象方法，那么role变量就无法调用，在BaseRole删除move方法。可以看到已经发生了B错误哈。

问题：

在drawFrame方法中描述每个角色业务时都需要调用  方法完成角色图像的位置，调用move方法完成角色的移动，调用rect方法完成碰撞区，这样显得很繁琐，大家思考一下这段代码可以优化吗？



# 第18章、迪米特法则

大家好在上一讲中，我们讲解了依赖倒置原则，依赖倒置原则就是应用多态时有父类变量和接口变量完成两个类之间的耦合，利用抽象偶和代替具体耦合的方式增加代码灵活性和通用性，多态在JAVA中应用的非常广泛，大家需要多加理解做到灵活运用，

不过在drawFrame方法中描述每个角色业务时都需要调用drawMysef方法，完成图像的绘制，需要调用方法完成角色的移动，需要调用rect方法完成碰撞区的一段将书写，显得很繁琐。那么这段代码，应该如何优化呢？

我们的看一下第五个设计原则迪米特法则，迪米特法则是这样表述的,一个软件实体应当尽可能少的与其他实体发生交互作用。这句话应该如何理解呢？

我们来举个例子，比如一个人想学开车，那么需要一个教练来指导，需要一部车子来练习，需要有场地来练车，还需要考驾照，那这样的话，这个人想去开车，就需要和众多人和众多的部门打交道，很繁琐，也很累，怎么办呢？于是他可以找一个驾校，由驾校安排教练，由驾校安排车子，由驾校安排场地，由驾校安排考驾照，将驾校大学生过程中需要用到的设备人员准备齐全，以后学员只需要面对驾校就可以了，对学员而言，就把和众多人员众多部门的交互变成了只和驾校交互，而且如果在学车过程中，有什么事情发生？

比如，车子有问题，考驾照未通过等等，也有驾校来解决，将交互减少以后，学员就轻松了很多，这就是迪米特法则的应用。

在举一个例子。比如，一个人想装修房子，那么需要买瓷砖，需要买水泥，需要请工人，还需要电钻，梯子等工具。如果他想省事儿就干脆找一个装修公司，装修公司负责买瓷砖，买水泥等装修材料，装修公司负责找工人施工，装修公司负责提供装饰工具，这样客户就把众多的交互过程变成只和装修公司进行交互，如果装修过程中，有什么问题也可以及时解决，比如地板没有铺平，客户向多做个壁橱等等，那么由装修公司负责解决，这就是所谓的只需要一个电话，其余的我们来做。

其时用的也是迪米特法则，生活中这样的例子还很多，很多电器都是把需要的电器元件进行封装，只留给用户很少开关和接口进行交互，比如开关，音量等等，用户不用关心电器的具体结构，只需要知道如何使用电器铺路的开关接口，完成电器操作就可以了。

问题：迪米特法则

其实迪米特法则就是封装的思想，把一个业务中所有的操作进行封装以后，只需要向外界透露很少的交互方法。这样当业务发生变化时，只需要更改业务就可以了，而不用更改，调用方在代码设计模式中的外观模式应用的就是狄米特法则

方法：drawFrame ----  

我们来看一下drawFrame方法中，在描述众多角色业务时都需要调用Image方法完成角色图像的绘制，需要调用move方法完成角色移动，需要调用rect方法完成碰撞区的一栋等等，书写不仅繁琐，而且如果我们需要在教师那种继续抽象方法时，那么所有的角色都会在调用该方法，这样就会导致因为一个类业务的变化而导致另一个类的变化，我不是看一下，应该如何应用迪米特法则来优化这段代码

方法：drawMySelf ---- BaseRole 

打开BaseRole。

我们在drawMySelf方法中调用move方法完成角色的移动，在调用setRect方法完成碰撞区的移动，

将在描述每个角色业务时只需要关注drawMySelf方法就可以了。不用再去关心其他方法，其他方法由drawMySelf方法统一进行调用，向外界只曝露这么一个方法。这样对角色运有方法的描述，只需要关注drawMySelf方法就可以了，move移动方法、setRect角色碰撞区移动方法就可以删除了，这样我们就把刚才BaseRole中的多次交互变成了一次交互，一旦BaseRole中又发生变化以后，不会影响drawMySelf方法调用。

方法： keyReleased --- PressKeyEvent

问题：发出的子弹不进行移除会有什么后果

我们来看一下，发射子弹的业务。

再键盘弹起事件中添加子弹对象，不过子弹只有添加而不见移除。这就意味着即使子弹超出屏幕也会在集合中存在。只是窗体中不会显示，这样的后果就是集合中子弹越来越多变，随着时间越来越长，游戏也越来越卡，所以集合中的子弹对象必须及时清除，不仅仅是子弹，其他角色也会有这样的问题。其实对于玩家而言，只会关注窗体中正在绘制角色，而不会关注窗体之外的角色，所以我们应该添加角色超出窗体以后自动从角色集合中移除的方法，这个行为是属于角色公有的行为，

方法：removeThis --- BaseRole

所以应该在BaseRole父类中定义新建removeThis方法，用于描述当角色超出屏幕以后从角色集合RoleList中移除，判断当前角色的X坐标如果大于1500，窗体的宽度是1000所以X坐标大于1500的时候已经在屏幕之外，多出了500主要是考虑到很多怪物是在屏幕外产生的，预留500个像素给屏幕外产生的怪物，或者X坐标小于-500或者Y坐标小于-500或者Y坐标大于1200。那么从GameStartFrame中访问角色集合，移除当前角色对象，很显然removeThis方法也需要在线程调用，这样角色在超出屏幕以后会自动从角色集合中移除，这时我们BaseRole的业务已经有所变化，不过我们可以在drawMySelf方法中调用Remove This方法。

对drawMySelf方法没有任何影响，这就是迪米特法则的优点，当业务发生变化时，只需要更改以有力就可以了，而调用方不会发生任何变化，不会因为一个类业务的变化而导致另一个类也变化

我们讲解的迪米特法则，大家多理解一下，

问题：

大家思考一下，地图类也需要绘制地图，图片也有移动的方法，那么我们应不应该把地图类也继承BaseRole达到代码重用呢。

# 第19章、里氏替换原则

大家好在上一讲座，我们讲解的迪米特法则让 GameStartFrame和BaseRole之间交互尽量减少，把原来BaseRole中众多方法的调用变成了一次方法调用，这样当BaseRole之中业务发生变化是不会影响GameStartFrame中调用方第二的变化，在游戏中地图类也需要绘制地图，图片也有一定的行为，那么我们应不应该把地图类也继承BaseRole这个父类，从而达到代码重用呢，我们来看一下第六个设计原则，里氏替换原则，

问题：里氏替换原则

里氏替换原则是这样定义的，在一个软件系统中子类应该能够完全替换任何父类，能够出现地方并且经过替换后不会让调用父类的客户程序从形式上有任何改变，里氏替换原则是用以判断两个类之间是否存在父子关系的原则，那么如何判断两个类之间是否具有继承关系呢？

很简单，用is来判断，比如，马是动物，那么马类继承动物类，玫瑰是植物，那么玫瑰继承植物，那人的时候，我们会说你是猪啊！那么，这个人继承猪的肥胖，继承猪的与半，这就是所谓的以A。

在前面几讲中光提到的继承的一些缺陷，一、无法通过继承的方式，重用多个类的重要的代码，二、父类的属性和方法，子类无条件继承，这一讲我们重点关注第二点，父类的属性和方法子类无条件继承，那么这就意味着，使用继承很容易造成方法的污染，我们来看一个例子，有一个枪类。

在枪类中定义的一个发射子弹的方法，有一个子类，AK47，该类继承枪类，所以发射子弹的方法可以从父类继承过来，那么还有一个类，玩具，枪这个类应不应该是枪的子类呢，玩具枪也能发射子弹，所以现在看起来玩具枪，可以是枪的子类。不过，如果再枪类中添加一个杀人的方法，那么玩具枪就会无条件继承杀人的方法。那么某个杀人狂拿着枪，到处杀人这句话本身没有问题，枪换成子类AK47，某个杀人狂拿着AK47到处杀人，也没有问题。

不过按照玩具枪是枪的子类的说法，那么某个杀人狂拿着玩具枪到处杀人，也应该可以成立，但是事实上，这是不成立的，因为玩具枪中没有杀人的方法，枪这个父类中杀人的方法，在玩具枪子类中并不适用，玩具枪此类并不能完全替换枪这个父类出现的地方，从以上例子可以看出里氏替换原则描述的是父类的属性和方法子类无条件继承，所以如果子类不能完全的实现父类的方法，或者父类的某些方法在此子类中发生畸变，则建议断开父子继承关系，采用依赖聚合组合等关系代替继承，

里氏替换原则。

我们可以简单理解为只有当父类中所有属性和方法，在子类中都是适用的，那么这两个类之间才具有父子关系。比如，鸵鸟是不是鸟呢，如果在鸟中只定义羽毛属性和下单的行为，那么鸵鸟完全适用，鸵鸟就应该是鸟的子类，但是如果在鸟中定义飞行的行为，由于鸵鸟不具有飞行的行为，父类方法在子类中已经发射畸变，所以这时就应该断开鸵鸟和鸟的父子关系。老爸在骂儿子的时候，说我没你这样的儿子，原因是什么呢？是因为老爸的优秀品质在儿子身上发生畸变，所以按照里氏替换原则，应该断开老爸和儿子之间的父子关系。

在开发中两个类之间是否具有父子关系主要取决需要，如果父类中所关注的属性和方法。在此子类中完全适用，那么就应该建立父子关系，否则应该断开父子关系。

问题：那么在游戏中地图类应不应该继承BaseRole这个父类呢？

地图类也需要绘制图片也需要移动。似乎和BaseRole中角色是很像的，但是我们来仔细看一下BaseRole这个父类。在BaseRole角色父类中定义了碰撞区域这么一个属性，该属性并不适合地图类，因为地图只是一个背景，所有角色都在地图上绘制，也就是说所有角色随时都在和地图碰撞，而角色和第一次碰撞以后不会发生任何事件。

另外在BaseRole中还定义removeThis方法，当角色超出屏幕以后，需要从角色集合中移除，这个方法对地图的而言是毁灭性的，在游戏中任何时候都应该先绘制地图，然后再绘制角色，如果地图类继承BaseRole父类，那么remove This方法将会无条件继承。这就意味着在开始的时候，有地图一旦，也是坐标小于-500之后，那么就会从角色集合中移除地图，后面的游戏就再也看不到地图了，所以removeThis方法在地图子类中发生畸变，从这里可以看出地图类并不适合BaseRole角色父类中定义的所有属性和方法，所以按照里氏替换原则，应该断开地图类和BaseRole的父子关系

这一讲我们讲解的里氏替换原则，大家理解一下，

大家思考一下，在BOSS、红色飞蛾、灯怪这些底层之中，除了有BaseRole中定义的角色属性之外、方法，还有哪些自己特有的属性的方法，希望大家运用开闭原则，抽象一下。

 





# 第20章、抽取怪物类（里氏替换原则）

大家好，在上一讲中，我们了解了里氏替换原则，
了解了如何判断两个类之间是否具有父子关系。
不过，在BOSS，红色飞蛾，灯怪这些怪物之中，除了有BaseRole角色父类中定义的属性和方法以外，还有一些共同的属性和方法。

这一讲，我们把这些怪物共同的特征和行为，在BaseRole角色父类基础之上，再进行抽取，怪物还是角色，“是”就表示怪物应该是BaseRole的子类。
 只不过怪物代表的是BaseRole中的一部分子类。
比如BOSS，红色飞蛾、灯怪这些类。除了有BaseRole角色父类中定义的属性和方法以外，还有一些怪物共同的属性和方法。

所以我们应该将怪物类继承BaseRole，在BaseRole基础之上。在描述怪物特有的共同的特征和行为。

### 问题：分析怪物共同的特征和行为

首先，怪物应该都有生命，不同的怪物生命值是不同的。
另外，怪物被打死以后，应该都会增加得分。不足的怪物，得分是不同的，这也叫打死怪物之后的经验值，所以我们应该把生命和经验做成怪物的属性。

怪物有哪些共同的行为呢？

游戏的玩法就是玩家控制主角发射子弹打击怪物，所以每个怪物都应该提供被击中的方法，当子弹击中怪物以后，调用该方法减少怪物的生命，当生命减少到0时，表示怪物被打死，应该从角色集合中移除怪物。

### 新建类：EnemyRole

我们新建一个类。EnemyRole，用于描述怪物共同的属性和方法，
包名为roleEnemy，在该包中存放所有的怪物类。

将EnemyRole继承BaseRole，添加构造方法。

### 问题：是否继承父类中的move抽象方法

在BaseRole中，有一个move（）抽象方法，用于子类描述自身特有的移动方式和行为的描述，那么EnemyRole应不应该重写move（）方法呢？
很显然，不同的怪物都会有自己特有的移动方式以及攻击方式，move（）方法，也应该由不同的怪物类描述自己的行为，
但是在BaseRole中，move（）方法是抽象方法。如果EnemyRole不重写该方法，那么无法通过编译，不过EnemyRole是不是必须重写move（）方法呢？
一个类继承一个抽象类，如果不全部实现抽象父类中定义的抽象方法。那么该类自然是抽象类，
同样，一个类实现一个接口，如果不全部实现接口中定义的抽象方法。那么该类也只能是抽象类。

由于move（）方法应该由怪物的子类根据自身的特点来具体实现，所以应该把怪物类EnemyRole做成抽象父类。在怪物父类中，我们定义怪物共同的特征。

### 属性：hp、exp

生命和经验，同样需要完成初始化，我们在构造方法中，在传入两个形参，生命和经验。
在构造方法中完成生命属性和经验属性的初始化。
这样，在构建怪物时，除了需要传入坐标和大小之外，还需要传入怪物的生命和经验

### 方法：byHit

在怪物父类中，我们定义怪物共同的行为，
定义byHit方法，用于描述怪物被击中的行为，
形参定义为怪物被击中时需要减少的生命，reduceLife，
这是因为女孩会发出好几种子弹，有飞镖，有菱形飞镖。
还有宠物吐出的火，也可以攻击敌人，
而每种子弹伤害是不一样的，所以怪物应该减少的生命， 应该由调用方传过来。

在byHit方法中，将当前怪物的生命减去reduceLife，当怪物生命减少到零或零以下时，怪物就被打死，

判断属性HP是否小于或等于零，如果满足，
那么从GameStartFrame中访问角色集合，然后移除当前怪物对象，
同时怪物被打死以后，应该增加玩家得分，
玩家得分是玩家玩游戏时的总得分，所以是唯一的，
应该把玩家的得分变量做成静态变量

### 属性：静态整型变量score  -----  GameStartFrame

打开GameStartFrame这个类，定义公有的静态变量score，在怪物类的byHit方法中，如果怪物被打死，那么访问玩家的得分变量，累加当前怪物的经验值。

### 新建类：Detonte

另外，怪物被打死以后，应该增加爆炸效果，
在role这个包中，新建爆炸类Detonate。继承BaseRole

添加构造方法，重写move（）方法， 
定义爆炸图片数组detonateImage，

### 属性：detonateImage

爆炸图片我们使用bomb文件夹中图片，

### 操作：CutImage.cutOneImage  ------ initImage.init()

打开initImage类，在init方法中完成爆炸图片初始化，调用CutImage.cutOneImage（）方法，传入图片路径。切割的图片数5，媒体跟踪器tracker和媒体跟踪器的分组数为1，

### 操作：ImageChange

回到爆炸类，定义图片切换算法工具类对象。
属性名定义为changeObj，切换频率定义为2，

### 构造方法：Detonte

在构造方法中，因为每个爆炸效果大小都一样，所以删除大 小形参的定义，
在super（）方法中传入爆炸大小，100*100，爆炸的坐标应该是怪物的坐标，所以需要定义形参传递过来，

### 重写：move

在move（）方法中调用changeObj的change（）方法传入爆炸图片数组完成图片切换，并对属性roleImage赋值，完成爆炸图片切换

### 属性：count

爆炸效果应该在一定时间之类消失 ，定义计数器变量count，

### 重写：move

在move（）方法中，将count自增，如果couunt大于十，在角色集合中移除当前爆炸对象。

打开怪物父类EnemyRole，在怪物被打死以后，在角色集合中添加爆炸效果，也就是添加一个爆炸对象，爆炸位置定义为当前怪物的位置。

### 方法：createDetonate

我们也可以这样写，在怪物父类中定义createDetonate（）方法。
在该方法中添加爆炸效果，然后在角色集合中添加爆炸对象。 在byHit方法中调用该方法。

### 问题：为什么不在byHit方法中直接添加爆炸对象（开闭原则）

这种写法和在byHit方法中直接添加爆炸对象，有什么区别呢？
区别在于，由于createDetonate是方法，所以该方法可以被子类所重写，
一旦某个怪物打死以后有不同的爆炸效果时，可以重写该方法，
重写以后，调用时会优先调用子类重写的方法，从而产生不同的爆炸效果，
这样写其实是预留方法给子类扩展，这就是开闭原则中的开，

### 新建类：boss

将 boss类移动到怪物包中，继承EnemyRole怪物父类，设置怪物的生命值为400，经验值为10000

 怪物父类定义好了，下一讲，我们讲解如何产生怪物。



# 第21章、产生怪物（1）

大家好，在上一讲中，我们完成的怪物共同特征和行为的抽取
这一讲我们以机器狗为例，完成怪物的产生，了解原理以后，其余怪物的产生，大家可以自己完成

### 新建类：RobotDog

我们在怪物包中，新建机器狗类RobotDog，继承EnemyRole怪物父类，添加构造方法，重写move（）方法。

### 属性：dogImage

添加机器狗图片数组，dogImage。
机器狗图片在image/enemy文件夹中

### 操作：CutImage.cutOneImag    ------ initImage.init() 

打开initImage，完成机器狗图片的初始化，调用CutImage的cutOneImag（）方法，传入图片路径，切割图片数4，媒体追踪器tracker以及媒体跟踪器的分组1，回到机器狗类。

### 操作：ImageChange

定义图片切换算法工具类对象changeObj，切换频率定义为4，

### 构造方法：RobotDog

在构造方法中需要完成机器狗坐标，大小以及生命值和经验值的初始化，
删除定义的形参，机器狗大小设置为150*150，
机器狗创建的起始位置，我们定义为窗体的右面，也就是在窗体外产生，所以机器狗的起始位置应该是1000到1500之间，
不能大于1500，大于1500以后，怪物会自动从角色集合中移除，
（在BaseRole父类中有角色移除的方法）

机器狗起始Y坐标，我们设定为100到500之间，
机器狗的坐标。我们通过随机数产生，这样每一次出现机器狗的位置都不一样，

将机器狗起始的X坐标书写为Math.random，这是0到1之间的随机数，
乘以500产生0到500之间的随机数，再加上1000就产生了1000到1500之间的随机数，强转为整型，
机器狗起始的Y坐标，书写为Math.random乘以400，产生0到400之间的随机数，再加上100就产生了100到500之间的随机数，强转为整型。

生命值设置为20，经验值设置为100，这样就完成了机器狗属性的初始化。

### 重写：move

在move（）方法中，描述机器狗的行为，
机器狗行为很简单，需要进行图片切换，然后从右到左移动，
调用changeObj的change（）方法，传入机器狗图片数组，并完成对属性roleImage的赋值，
将机器狗X属性累减8个像素，完成机器狗的移动，机器狗类书写完毕，

### 操作：roleList.add ------GameStartFrame.drawFrame

机器狗类需要在游戏线程中产生。
我们在GameStartFrame类的drawFrame方法中，在角色集合中添加机器狗对象，
调用roleList的add方法传入机器狗对象。

运行一下。

### 问题：产生怪物时为什么需要计数器变量

可以看到，铺天盖地的机器狗向主角扑过去。

原因是，我们直接在drawFrame方法中完整对机器狗对象的添加，而drawFrame方法在线程中调用，每隔20毫秒就调用一次，也就意味着每隔20毫秒就产生一个机器狗对象。这样的结果就是产生铺天盖地的机器狗，显然机器狗产生的比例太快，

### 问题：如何让机器狗产生的频率慢下来呢？

我们可以做一个计数器，在一定时间之后再产生机器狗。
由于这需要一定的算法，
按照单一职责原则，我们应该新建产生怪物类，专门描述产生怪物的业务，

### 新建类：CreateEnemy

在工具包中新建产生怪物工具类CreateEnemy，

### 方法：createRobotDog  -----  CreateEnemy

定义方法createRobotDog。
为了方便在GameStartFrame中调用，所以将该方法做成静态方法，
这样，类名点的方式可以直接调用，

### 属性：dogcount  -----  CreateEnemy

新建计数器变量dogcount。
由于静态方法不能直接访问成员变量，所以将dogcount做成静态变量。

在产生机器狗方法中，将dogcount自增，
判断dogcount是否大于100。
如果大于100，将dogcount归零，
然后在角色集合中添加一个机器狗对象。
这样就表示2秒钟产生一个机器狗对象

### 操作：roleList.add ------GameStartFrame.drawFrame

打开GameStartFrame类，在drawFrame方法中完成对创建机器狗方法的调用，调用CreateEnemy中的产生机器狗的方法完成机器狗对象的产生。
运行一下。
可以看到，2秒钟产生一个机器狗对象。
当然，这个算法大家可以自己定义，
比如，我们可以在2秒钟之后随机产生几个机器狗对象，
在产生机器狗的方法中，书写FOR循环
i <= Math.random()*4
随机产生一个到四个的随机数，
也就是在角色集合中随机添加一个到四个机器狗对象。

运行一下。
可以看到有时候三个，有时候两个，有时候一个。
这样随机产生了几个机器狗对象。

# 第22章、一定区域类产生怪物



大家好在上一讲中，我们完成的机器狗的产生。
另外有些怪物是在地图滚动到一段区域之类才产生的。
我们以灯怪为例，讲解如何在地图滚动到一段区域之类产生怪物。

### 新建类：LightEnemy

我们在怪物包中，新建灯怪类LightEnemy，继承EnemyRole怪物父类，
添加构造方法，重写move（）方法，

### 属性：lightImage

添加灯怪图片数组lightImage。
灯怪图片路径image/enemy/lightEnemy。

### 操作：CutImage.cutOneImage  ------ initImage.init()

打开initImage类，在init（）方法中，完成灯怪图片的初始化。
调用CutImage的cutOneImage方法，
传入图片路径，传入切割图片数2， 传入媒体跟踪器tracker，传入媒体跟踪器的分组1。

### 操作：ImageChange

回到灯怪类。
定义图片切换算法工具类对象，变量名定义为changeObj，切换频率定义为三，

### 构造方法：LightEnemy

在构造方法中需要完成灯怪坐标和大小的初始化，以及生命值和经验值的初始化，
删除灯怪形参的定义，
灯怪光大小设置为180*200，

灯怪创建的起始位置，我们定义为窗体下面，
在窗体外产生，然后向上移动到窗体之中，
所以灯怪的起始X坐标设定为50到500之间
灯怪起始的Y坐标，我们设定为700到1200之间，灯怪的坐标我们也通过随机数产生。
产生0到450之间的随机数，再加上50产生50到500的随机数，强转为转型。
灯怪起始的Y坐标，产生0到500之间的随机数，再加上700，产生700到1200的随机数将转为整形。
生命值设置为30，经验值设置为200。

### 重写：move

在 move（）方法中定义灯怪的行为，灯怪行为很简单，
首先需要进行图片切换，然后从下往上移动，
调用changeObj的change（）方法，传入灯怪图片数组。
并完成对属性roleImage 的初始化，然后将属性Y累减十个像素，
灯怪类书写完毕，

### 方法：createLight   -----  createEnemy

打开产生怪物工具类CreatEnemy，定义静态方法完成灯怪的产生，
定义静态方法createLight，完成灯怪的产生，

### 属性：lightcount   -----  createEnemy

新建静态计数器变量lightcount，在产生灯怪方法中，
将liaghtcount自增，当lightcount大于50时。将lightcount归零
然后在角色集合中添加灯怪对象。也就是1秒钟产生一个灯怪，

### 问题：滚动到一定区域后产生怪物

但是灯怪不像机器狗，一进入游戏就立即产生，灯怪需要在地图滚动到一段固定区域才产生，那么我们需要访问到地图的X坐标，根据地图的X坐标产生灯怪。

由于地图是唯一的、是所有角色共享的，地图的坐标也是所有角色共享的，所以我们可以将地图的X坐标设置为公共的静态变量。

这样，通过类名点的方式，可以直接访问，在产生灯怪的方法中，判断地图的X坐标。如果在负的1800到-500之间，那么再完成灯怪的产生。

### 操作：roleList.add ------GameStartFrame.drawFrame

打开GameStartFrame类，在drawFrame方法中，调用产生灯怪的方法。

运行下。
刚开始没有灯怪。地图滚动到-500以后产生灯怪。过了-1800以后，又没有灯怪产生。
所以，完成了灯怪在一段区域之类产生的效果。

### 问题：（迪米特法则）是不是有几种的怪物，我们就得书写几种产生怪物的方式，并在drawFrame方法中，完成调用呢？

我们来看一下drawFrame方法，
在产生机器狗时，调用了产生机器狗的方法，
在产生灯怪时，调用了产生灯怪的方法。

那么是不是有几种的怪物，我们就得书写几种产生怪物的方式，并在drawFrame方法中，完成调用呢？
按照迪米特法则，软件实体之间应当尽量减少交互，
所以我们应该在CreateEnemy中再定义静态方法create() , 用于怪物的产生。

### 方法:create ------ createEnemy

在create方法中完成对产生机器狗方法的调用，
再完成产生灯怪方法的调用

### 操作：CreateEnemy.create  ----- GameStartFrame.drawFrame

打开GameStartFrame类。
那么，现在产生怪物只需要调用create方法就可以了，
这样把之前的多次交互减少为一次交互，
如果需要产生别的怪物，只需要修改CreateEnemy类中的create方法，
在create方法中，在调用产生其他怪物的方法就可以了，
不会对调用方drawFrame造成任何影响。

这一讲，我们完成了灯怪的产生，还有一些boss级别的怪物在地图滚动到一定位置才产生
同时，地图需要停止滚动。
另外有些怪物还要发射子弹。这应该如何实现呢？大家可以先实现一下，下一讲，我们继续完成怪物的产生。

# 第23章、产生怪物并停止地图滚动

大家好在上一讲中，我们完成灯怪的产生，还有一些boss级别的怪物在地图滚动到一定位置时产生，同时，地图需要停止滚动。
另外，有些怪物还需要发射子弹，这一讲以红色飞蛾为例，讲解如何产生boss级别的怪物，

### 新建类：RedMoth

我们在怪物包中，新建红色飞蛾怪物类RedMoth。
继承EnemyRole怪物父类
添加构造方法，重写move（）方法，

### 属性：mothImage

添加飞蛾图片数组mothImage。

### 操作：CutImage.cutOneImage  ------ initImage.init()

打开initImage类，在 init方法中完成飞蛾图片的初始化。
调用CutImage的 cutOneImage方法，
传入图片路径，传入切割的图片数三，传入媒体跟踪器，传入媒体跟踪器的分组一，

### 操作：ImageChange

回到飞蛾类，
定义图片切换算法工具类对象，
变量名设置为changeObj，切换频率设置为四，

### 构造方法：RedMoth

在构造方法中需要完成飞蛾坐标、大小、以及生命值和经验值的初始化，
删除飞蛾形参的定义，飞蛾大小设置为260*280。
由于飞蛾属于boss级别的怪物，所以在地图滚动到一定位置时只会产生一个，
所以可以把坐标设置为定值，
初始x坐标设置为1100，初始Y坐标设置为100，生命值设置为300，经验值设置为5000。

### 问题：分析飞蛾在地图上的移动行为

我们来定义飞蛾的行为，
在地图滚动到一定位置时，在窗体外产生飞蛾，
先让飞蛾从右到左移动到窗体，
在飞蛾到达屏幕中某个位置后，上下来回移动，并发射子弹。

在飞蛾被打死以后，地图继续滚动，
从这里我们可以看出飞蛾有几种状态：
产生飞蛾从右到左，这是初始状态，这时不发射子弹。
在飞蛾上下来回移动时，属于正常状态，这时需要发射子弹。

### 属性：INIT、DOWN、UP

我们在飞蛾类中定义描述飞蛾状态的常量
常量INIT，初始值设置为零，初始状态
常量DOWN，初始值设置为1，表示飞蛾向下移动的状态。
常量UP，初始值为2。表示飞蛾向上移动的状态。

### 属性：status

再定义飞蛾的状态属性是status。初始值赋值为INIT。
表示产生飞蛾后初始状态为INIT。

### 重写：move

在move（）方法中，描述飞蛾的行为，
首先需要做图片的切换，调用changeObj的change方法，
传入飞蛾图片数组，并完成对属性roleImage的赋值。

根据不同的状态，完成飞蛾的移动，
判断飞蛾的状态为INIT时，
将X坐标累减12个像素，判断X坐标小于等于700时，将状态更改为DOWN，
书写else，描述飞蛾正常状态的行为。
判断飞蛾状态是否为向下状态。将Y属性累加五个像素。
判断Y坐标是否大于400，如果大于等于400，将状态设置为向上状态UP。
在判断飞蛾的状态是否为向上状态，
如果飞蛾状态为向上，那么将Y坐标累减五个像素，判断Y坐标是否小于等于100。
如果Y坐标小于等于100，将状态设置为向下DOWN状态，
这样就实现了飞蛾上下移动，飞蛾的移动方式我们创建完毕。
另外，飞蛾处于正常状态时，会发射子弹。

### 问题：分析怪物发子弹的行为

现在我们完成怪物子弹的发射，
怪物子弹有很多种，每种子弹都有自己移动的轨迹和攻击的方式，
所以每一种怪物子弹应该新建一个怪物子弹类，
由于子弹没有生命，所以应该继承BaseRole角色父类

### 新建类：fireBall

在角色包中创建怪物子弹类fireBall，
这个怪物子弹是一个火球，继承BaseRole
添加构造方法，重写move方法，

### 属性: fireBallImage  -----  fireBall

添加火球图片数组fireBallImage。
火球图片在怪物子弹文件夹中

### 操作：CutImage.cutOneImage  ------ initImage.init()

打开initImage类完成火球图片的初始化。
调用CutImage的cutOneImag方法，
传入图片路径、传入切割图片数三、传入媒体跟踪器以及媒体跟踪器的分组1。

### 操作：ImageChange

回到火球类
定义图片切换算法工具类对象，变量名定义为changeObj，切换频率定义为三。

### 构造方法：FireBall

在构造方法中，需要完成火球坐标和大小初始化，
火球的大小设置为60*60，删除形参种高度和宽度的定义，
火球的坐标应该和飞蛾有关，所以需要通过形参传递过来。

### 重写：move

在move（）方法中定义火球的行为
首先进行图片切换，调用changeObj的change方法
传入火球图片数组，并完成对属性roleImage的赋值。

对于火球的移动行为，我们这样设定，
让飞蛾一次发射三个火球，水平方向的、左上方向的和左下方向的，
所以在产生火球时，需要指定火球移动的方向类别，

### 属性：LEVEL、LEFTUP、LEFTDOWN -----  ImageChange

创建公有的静态常量LEVEL，初始值设置为零，表示水平方向。
在创建公有的静态常量LEFTUP，初始值设置为一，表示左上方向
创建公共的静态常量LEFTDOWN，初始值设置为二，表示左下方向。

### 属性：direction  ----- ImageChange

定义方向属性direction。

### 构造方法：FireBall

在构造方法种定义形参direction
在构造方法中完成方向属性的初始化。

### 重写：move

在move（）方法中判断方向属性。
如果是水平方向。将属性X累减8个像素。
如果是左上方向。将属性X累减6个像素，将属性Y累减两个像素，
如果是左下方向。将属性X累减六个像素，属性Y累加两个像素，
这只是一个粗略的角度，如果想要更精细的算法，需要查一下3角函数，
火球的行为创建完成

### 属性：count  --- RedMoth

回到飞蛾类，飞蛾发射子弹需要有一定的时间间隔，可以定义计数器来控制敌人子弹的发射
定义计数器属性count。

### 方法：shoot ---- RedMoth

由于发射子弹业务较多，最好独立成一个方法
创建发射子弹方法shoot。

### 重写：move

在move方法中，飞蛾正常状态下调用该方法
这样完成了飞蛾正常状态时子弹的发射。

### 方法：shoot

将计数器count自增。
如果count大于100，将计数器count归零
在角色集合中添加火球对象，
火球的X坐标设置为飞蛾的X坐标加20像素，Y坐标设置为飞蛾y坐标加上20像素，
方向设置为水平方向。
这样产生了一个水平方向的火球对象。
再同时产生左下和左上方向的火球。
这样，表示飞蛾发射子弹时一次发射三颗子弹，分别是水平方向、左上方像和左下方向
飞蛾的行为我们完成了，

### 方法：createMoth  ----  CreateEnemy  

现在我们需要创建飞蛾怪物
打开产生怪物工具类CreateEnemy，创建产生飞蛾的方法createMoth
在create方法中完成产生飞蛾方法的调用，飞蛾需要在地图滚动到一段区域才产生，并且只产生一次。同时地图要停止滚动

那么我们需要访问地图类的mapx坐标，另外，
需要定义布尔变量来判断地图是否应该滚动

### 属性：isRoll ----  GameMap

在地图类中创建公有的静态变量isRoll，初始化为真。

在地图的drawMyself方法中，判断isRoll是否为真。
如果为真，再完成地图的移动。

### 问题：产生飞蛾并让地图停止滚动

回到产生怪物工具类。
在产生飞蛾方法中，判断地图X坐标是否小于负的2000。
如果地图的X坐标小于负的2000，在角色集合中产生一个飞蛾对象。
同时，让地图停止滚动，将变量isRoll设置为false，
由于飞蛾只创建一个对象，所以我们新建静态变量isCreateMoth，初始化为真。
加上条件判断，isCreateMoth如果为真，同时地图X坐标小于2000时产生飞蛾对象
当飞蛾对象产生以后，将isCreateMoth赋值为false
这样，确保飞蛾对象只产生一个
运行一下。

可以看到，地图滚动到-2000时，产生飞蛾，并且飞蛾在发射子弹，地图也停止了滚动。

### 问题：怪物被打死后让地图恢复滚动

那么，当飞蛾被打死以后，地图重新滚动，这个业务，我们后面再实现。

BOSS赵云应该在地图滚动到最后时产生，算法和飞蛾类似，为了方便测试。
我们还是在游戏主窗体创建时产生boss对象，我们了常见的几种怪物产生方式，大家也可以书写算法完成其他怪物的产生，并定义怪物的行为，
大家多体会下飞蛾类中关于状态的设置。
下一讲我们来看一下如何发射子弹将怪物打死。

# 第24章、发射子弹打死怪物

大家好，在上一讲中，我们了解了常见的几种怪物产生方式，
这一讲，我们来看一下如何发射子弹将怪物打死，

首先大家需要了解一下打死怪物是谁的行为，
是女孩的行为还是女孩儿发射子弹的行为，
打死怪物是女孩发射的子弹的行为，女孩只负责产生子弹，
所以打死怪物的业务逻辑应该写在女孩发射子弹之中，

### 重写：move ---- GirlBullet

打开子弹类GirlBullet。
在move方法中，书写打死怪物的业务，
我们应该判断子弹是否击中怪物
先从角色集合中取出现有的角色，然后判断子弹和角色碰撞区域是否相交，
遍历角色集合，书写for循环，i < GameStartFrame.roleList.size()

在循环体中取出角色对象，用变量role接收
判断当前子弹对象是否和角色相交，书写this.rec访问当前子弹的碰撞区域，在点intersects传入角色的碰撞区域role.rect

如果结果为真，表示子弹击中角色，
但是只有怪物才能被打死，我们现在只有BOSS、飞蛾、机器狗、灯怪四种怪物。

### 问题：判断子弹击中的是不是怪物（）

怎么判断role这个父类变量指向的是机器狗对象呢？
我们可以加上判断  role instanceof EnemyRole
判断role变量指向的对象是否匹配，指定类型，导包，如果匹配表示当前子弹击中的是机器狗对象。

将role 强转为机器狗对象。
用变量enemy接收，调用byHit方法，传入15，表示子弹击中机器狗之后，机器狗减少15点生命
怪物被打死以后会自动从角色集合中移除。

从角色集合中移除当前子弹对象。表示子弹击中敌人之后就消失
子弹击中敌人产生爆炸效果

运行一下。
发射子弹，可以看到机器狗已经被打死了，而且产生了爆炸效果。

打开子弹类。
继续判断当前子弹是否击中灯怪。 role instanceof EnemyRole

如果子弹击中了灯怪，将角色变量role强转为灯怪类型。
用变量enemy接收，调用灯怪的byHit方法，传入15，表示减少灯怪15点生病，然后从角色集合中移除当前子弹对象

运行一下
可以看到灯怪也被打死了。

回到子弹类

### 问题：（依赖倒置原则）是不是有几种怪物就得书写几种击中怪物的业务操作呢？

这样写相当繁琐，而且每增加一个怪物，每删除一个怪物都得去修改子弹击中怪物的算法。

对了，按照依赖倒置原则，我们应该面向抽象编程，而不是面对机器狗、灯怪这样具体的类编程，达到代码的通用性和灵活性。
所有怪物都继承于怪物父类，所以我们只需要判断当前角色是否是怪物就行了，没有必要一种怪物，一种怪物判断，管它是张三怪物还是李四怪物，通通打死，
删除灯怪的判断，将机器狗类型更改为EnemyRole 怪物父类类型。
将注释更改为子弹击中怪物
将角色变量role强转为怪物父类类型。
变量名更改为enemy，将怪物生命减少15点生命，
然后从角色集合中移除子弹对象，

这样就把击中怪物的业务简化成了一个判断，这就是面向抽象编程的好处

运行一下。
可以看到机器狗和灯怪都被打死了。
红色飞蛾出现了，红色飞蛾也被打死了。
BOSS也被打死了。

如果以后再添加别的怪物，子弹业务不会发生任何变化。

### 问题：子弹击中怪物时产生小爆炸

为了美观一点，子弹击中之后应该有一个击中的效果，我们就做成一个小爆炸效果

### 新建类：Blast

在角色包中，新建小爆炸类Blast。将Blast继承BaseRole
添加构造方法，重写move方法

### 属性：blastImage   ------  Blast

定义小爆炸图片数组，图片在image文件夹中

### 操作：CutImage.cutOneImage  ------ initImage.init()

打开工具类InitImage，在其init方法中，完成小爆炸图片的初始化
访问小爆炸图片，调用CutImage.cutOneImage方法
传入图片路径，传入切割图片数4、传入媒体跟踪器以及媒体跟踪器的分组。

### 操作：ImageChange

回到小爆炸类
定义图片切换算法工具类对象ImageChange，命名为changeObj，切换频率定义为2。

### 构造方法：Blast

在小爆炸构造方法中删除宽度和高度形参的定义。
将宽度和高度初始值设置为50*50，小爆炸坐标应该是击中怪物后子弹的坐标，需要定义形参传递过来，

### 重写：move  -- Blast

在move方法中，调用changeObj 的 change方法完成小爆炸图片的切换，传入小爆炸图片数组，并完成对属性roleImage的赋值。

### 属性：count --- Blast

爆炸的效果应该在一定时间之类消失，定义计数器变量count。
在move方法中，将count自增，
如果count大于8，从角色集合中移除当前小爆炸对象。

### 重写：move  ----  GirlBullet

打开子弹类
在子弹击中怪物时从角色集合中移除子弹对象。同时添加小爆炸对象。
小爆炸对象起始的X坐标设置为当前子弹的X坐标减去30像素，
起始的Y坐标设置为当前子弹的Y坐标。

运行一下
可以看到当子弹击中怪物以后产生了爆炸的效果。

### 问题：属性和静态变量的区别

在游戏中，我们在很多地方都使用的静态变量，比如角色集合，地图的X坐标等等，
可能有些同学觉得静态变量很好，用访问起来很方便，但是静态变量是唯一的，是所有对象共享的变量，
它的改变会影响所有的对象，

我们来看一下，打开角色的父类BaseRole，将角色的X坐标设置为静态变量。
大家思考一下，这样会有什么样的结果，

运行一下。可以看到所有角色的x坐标都是一样的。
而且造成的很多我们不想看到的效果。
很显然，这并不符合我们的需要
每个角色坐标很明显都不会相同，所以角色的坐标应该是属性，将BaseRole中的x变量做成属性

大家需要掌握属性和静态变量的区别
属性，是包含在对象之中的，是一个对象的组成部分，也叫成员变量，不同的对象属性值是不同的，一个对象属性的变化，不会影响另一个对象属性的变化
而静态变量是唯一的，是所有对象共享的变量，它的改变会影响所有的对象

这一讲我们完成了打死怪物的算法，大家多理解依赖倒置原则的好处，有些怪物打死以后会产生道具，这个业务应该如何书写呢？

我们下一讲来完成产生道具算法。



# 第25章、产生道具

上一讲中，我们完成打死怪物的算法。
不过有些怪物打死以后会产生道具，这个业务如何书写呢？

这一讲我们来完成产生道具的算法。

### 新建类：Prop

首先在角色包中，新建道具类Prop，将其继承BaseRole
添加构造方法，重写mvoe方法
道具的图片在image文件夹中

这张图片有三个小图片，代表不同类型的道具，
有POWER道具表示增加火力
有BOMB道具表示增加炸弹
有LIFE道具表示增加女孩一条生命。
当然，如果还有别的道具，大家可以自己添加并书写相关的业务。

在道具类中，在道具类中定义道具的图片propImage，
在InitImage类的init方法中，完成道具图片的初始化，
访问道具，图片调用CutImage.cutOneImage方法，
传入道具图片路径。传入切割图片数3，传入媒体跟踪器以及媒体跟踪器的分组。

回到道具类
定义道具类型常量POWER，初始化为0，表示火力道具。
定义道具类型常量BOMB，初始化为1，表示炸弹道具
定义道具类型常量LIFE，初始化为2，表示生命道具。

定义道具类别属性type。

### 构造方法：Prop

在构造方法中，需要完成道具的坐标和大小的初始化
大小设置为65*40，坐标为打死怪物的坐标，需要传过来，删除形参高度和宽度的定义

定义形参变量type，在构造方法中完成type属性的初始化

### 问题：道具图片在游戏中的显示有什么不同

道具的图片，应该根据不同的类别显示不同的图片
在游戏运行中道具图片不会发生变化，可以在构造方法中完成道具图片初始化

判断type是否为火力类别，
如果是火力道具，将当前角色的图片设置为道具图片数组的第一个元素。
如果是炸弹道具，将角色图片设置为道具图片数组的第二个元素
如果道具类别type是生命道具，将角色图片设置为道具图片数组第三个元素。

### 重写：move

在move方法中，描述道具的行为
道具的移动方式很简单，从右到左移动，
将属性X累减三个像素
当女孩和道具相碰时，应该改变相应的数据，所以在道具类中应该设置道具和女孩碰撞的算法
判断当前道具对象是否和游戏中的女孩相碰，调用当前道具碰撞区域的intersects方法，访问GameStartFrame中的女孩对象，在访问rect碰撞区域，
如果结果为真，表示当前道具和女孩对象相碰，那么将玩家的得分增加500。

然后，判断道具的类别，

如果是火力道具。

### 方法：addPower --- Girl

打开女孩类。
在女孩类中定义增加火力的方法addPower。
该方法我们在后面实现

回到道具类，如果道具类别为火力道具，那么访问GameStartFrame中的女孩对象，调用addPower完成火力的增加，

在判断，如果是炸弹道具。
那么，应该给女孩增加炸弹。
定义当前女孩炸弹数量属性BombNumber，初始值设置为4，表示默认有四颗炸弹。
生成get方法。

回到道具类，
如果当前道具是炸弹道具，那么访问GameStartFrame中的女孩对象并调用setBombNumber方法，将炸弹数量加一。

在判断，如果是生命道具。
在GameStartFrame中定义公共的静态变量girlNumber，初始化为三，表示开始时有三条生命。

回到道具类，
如果当前道具是生命道具，那么访问GameStartFrame中女孩的生命变量girlNumber，该属性自增，表示女孩增加一条生命，

在道具被女孩捡到以后会消失
在完成的道具业务以后，从角色集合中移除当前道具对象。

### 问题：道具对象在什么时候产生？

对了，是在怪物被打死以后产生，但是并不是所有的怪物打死以后都要产生道具，而且不同的怪物打死以后产生的道具可能也不相同，
有些boss级别怪物打死以后，可能是让地图恢复滚动，而大boss以后可能是游戏结束等等，

### 问题：所以怪物被打死以后可能需要完成的业务也不相同，如何描述怪物这个行为呢？

我们可以在怪物包中，新建一个接口IDie。
用于描述怪物打死以后，需要完成的业务。
在接口中定义leaveOver方法，由该方法描述怪物死亡以后需要完成的业务操作。

那么在怪物死亡以后，如果需要完成一些业务的怪物类可以实现该接口，完成当前怪物死亡后需要做的业务操作，

### 新建接口：IDie

打开灯怪类
将灯怪类实现IDie接口，重写接口方法。
在方法中向角色集合添加一个火力道具。
坐标设置为灯怪的坐标，类别设置为火力，类别表示灯怪打死以后产生一个火力道具

打开飞蛾类，
将飞蛾类也实现IDie接口，重写接口方法。
在方法中，我们产生一个随机道具，
在角色集合中添加一个道具对象，坐标设置为当前飞蛾的坐标。
类别产生0到2的随机数。
书写Math.random()*3，强转为整形，

这样就产生的随机类型的道具，
另外飞蛾死以后需要让地图恢复滚动，访问地图的isRoll变量，将该变量赋值为真，表示让地图恢复滚动

打开Boss类，
将boss类也实现IDie接口，
重写leave Over（）方法，在该方法中访问 GameStartFrame.isRun变量，这是游戏是否运气的变量，将该变量赋值为假，表示结束while循环，停止角色的绘制，从而停止游戏运行。

### 属性：isPass  --- GameStartFrame

同时，在GameStartFrame中
我们创建公有的静态变量isPass，表示游戏，是否通关。
很显然，在BOSS被打死以后，游戏通关，

所以在boss的leaveOver方法中访问isPass变量，将该变量赋值为真。
现在，

### 问题：（依赖倒置原则）所有IDie接口的leaveOver方法需要调用才能生效

打开怪物的父类EnemyRole。
在怪物被打死以后，有些怪物需要完成一些业务
按照依赖倒置原则，我们直接判断当前怪物对象是否匹配IDie类型。

如果匹配将当前怪物对象，强转为IDie接口类型，用变量d接收
调用d的leaveOver方法完成怪物死亡以后需要进行的业务操作。

运行一下。
可以看到灯怪打死以后产生火力道具。
飞蛾打死以后产生了随机道具。
boss打死以后，窗体停止绘制

这一讲，我们完成道具产生，但是怪物打死以后的得分、女孩的生命数量和炸弹数量。
这些游戏信息并没有在窗体中显示出来

下一讲，我们来完成游戏信息的绘制。

# 第26章、游戏信息绘制

大家好在上一讲中，我们完成道具的产生，并在某些怪物打死以后完成一些业务操作，
不过怪物打死后的得分，女孩还有几条生命，女孩还有几颗炸弹，这些游戏信息并没有在窗体中显示出来，

这一讲我们来完成游戏信息的绘制，

对窗体中角色图像的绘制，我们是采用Graphics双缓冲画笔调用drawImage方法完成的。
现在我们需要绘制的不仅有图像，而且还有文字，那么

### 问题：文字的绘制，应该如何实现呢？

在Graphics画笔类中定义的drawString方法，可以完成窗体文字的绘制，
该方法有三个参数，第一个参数为字符串，表示需要绘制的文字，第二个和第三个参数为会绘制文字的坐标。

另外，在Graphics双缓冲画笔中还定义了setFont方法，可以设置会绘制文字的字体，该方法参数为font字体类型。

如果我们希望改变绘制文字的颜色，可以调用Graphics双缓冲画笔类中的setColor方法，该方法参数为color颜色对象
有了这么几个方法，我们就可以将游戏信息绘制在窗体之中了。

### 方法：drawInfo ---- GameStartFrame

在GameStartFrame中创建绘制游戏信息的方法drawInfo。
游戏信息随时在改变，所以应该在线程中调用，并且游戏信息应该显示在最上层，

在drawFrame方法中，将所有角色绘制完成以后，再调用drawInfo方法完成游戏信息的绘制。
在GameStartFrame的构造方法中设置双缓冲画笔的字体和颜色
在创建双缓冲画笔之后，
调用memoryGraphics.setColor方法，将绘制字体的颜色设置为pink粉红色。

在调用双缓冲画笔的setFont方法，设置双缓冲画笔的字体，传入font字体对象，设置字体为黑体，字体类型为粗体，大小设置为20像素。

在drawInfo方法中，
首先绘制女孩生命。
调用双缓冲画笔的drawImage方法绘制女孩的图片，绘制的图片设置为女孩图片的第一个元素，访问女孩的图片数组，传入0，表示女孩图片数组的第一个元素，设置坐标、大小。
游戏信息绘制在类存中，故传入空值，
调用双缓冲画笔的drawString方法，传入文字，绘制坐标。
这样女孩的生命就绘制出来了

再绘制女孩的炸弹数量
调用双缓冲画笔的drawImage方法绘制炸弹图片，绘制的图片设置为道具图片的第二个元素。访问道具图片数组，传入1，表示道具图片数组的第二个元素，设置坐标、大小，游戏信息绘制类存中，故传入空值
绘制女孩炸弹数量，调用双缓冲画笔的drawString方法，传入文字，绘制坐标。
这样，女孩的炸弹数量就绘制出来了

再绘制玩家的得分
得分图片在image文件夹中
打开GameStartFrame，定义静态的得分的图片对象scoreImage
打开InitImge，完成得分图像初始化，访问得分图像对象，调用CutImage.getSingleImage方法，传入图片路径，传入媒体跟踪器以及媒体跟踪器的分组。

回到GameStartFrame类，绘制玩家得分，
首先调用双缓冲画笔的drawImage方法绘制得分图片。
设置坐标、大小，游戏信息绘制类存中，故传入空值
绘制得分，调用双缓冲画笔的drawString方法，绘制的文字为score分数，不过，这里要求传递字符串类型，将score分数转化成字符串类型，使用String.valueOf将传入的score分数，将其转化为字符串类型，
绘制坐标。
玩家的得分信息就绘制出来了

运行一下。
可以看到游戏信息已经显示出来。
而且，会随着游戏运行发生变化，打死怪物以后会增加得分。

这一讲，我们完成游戏信息的绘制
从下一讲开始，我们来完善女孩的动作。

# 第27章、女孩图片和状态的定义

大家好，在上一讲中，我们完成游戏信息的绘制，
从这一讲开始，我们来完善女孩的动作。

首先我们来看一下

### 问题：分析女孩的各种状态

女孩的图片，女孩图片一共有四张
分别是前进的动作连图，后退的动作连图，发大招时旋转的动作连图，以及死亡的图片，
四张图片，分别对应女孩的四种状态：前进状态，后退状态，旋转状态以及死亡状态。

其中前进状态又分为普通前进状态和无敌前进状态
差别在于普通前进状态，图片在动作连图中第一张和第三张图片之间切换
普通状态时女孩能被敌人打死，
无敌前进状态，图片在4张动作连图中切换，效果是女孩发着金光，无敌状态时女孩不能被敌人打死，

同样，后退状态，也分为普通后退状态和无敌后退状态。

另外，在女孩刚开始时，应该从屏幕外移动到屏幕中，这时玩家是不能控制的，这是女孩的初始状态。
我们在完善女孩动作之前，先对女孩相关的状态进行定义，然后通过一系列的事件改变女孩的状态，

我们看一下女孩状态的变化，

### 问题：分析女孩状态的变化

从屏幕外进入到屏幕之中，这是初始状态。
按下左键后，女孩处于后退状态。
按下邮件或不按方向键，女孩处于前进状态。
按下炸弹键后，女孩处于旋转状态。
被敌人或敌人子弹击中后，女孩处于死亡状态，

这一讲我们完成女孩图片的初始化以及状态的定义。

打开女孩类。
现在，在女孩那种定义的图片数组，其实是无敌前进状态的数组。
为了见明知意，需要将属性进行重命名。

### 问题：快速更改属性名的小技巧

选中属性名girlImage，单击右键选择重构，选择重命名。
将属性名更改为forwardFlickerImage，回车以后，可以做到全部修改，也就是原来调用该图片的地方全部都会更新。

定义普通状态前进数组forwardImage。
定义无敌状态后退数组backFlickerImage。
定义普通状态后退数组backImage。
定义旋转图片数组spinImage。
定义死亡图片dieImage。

打开InitImage完成女孩图片的初始化，
由于女孩图片较多，所以最好是独立成方法。

### 方法：initGirlImage  ----  InitImage

创建初始化女孩图片方法initGirlImage，传入媒体跟踪器，定义形参媒体跟踪器。
然后在init方法中调用该方法。

初始化女孩普通前进状态图片数组，访问forwardImage，创建图片数组。
数组元素定义为无敌前进状态图片数组的第一个和第三个元素。

完成女孩后退图片的切割，访问女孩无敌后退状态的图片数组backFlickerImage，
调用CutImage.cutOneImage方法
传入图片路径、传入切割图片数4、传入媒体跟踪器以及媒体跟踪器的分组
。
完成普通状态后退图片数组的初始化，创建图片数组，
数组元素定义为无敌状态后退图片数组的第一个和第三个元素。

完成旋转图像初始化，访问spinImage，调用CutImage.cutOneImage方法
传入图片路径、传入切割图片数12、传入媒体跟踪器以及媒体跟踪器的分组。

完成女孩死亡图片的初始化，访问dieImage，调用CutImage.getSingleImage方法
传入图片路径、传入媒体跟踪器以及媒体跟踪器的分组

女孩图片初始化完成

### 属性：INIT、FORWARD   -----  Girl

### 属性：BACK、SPIN、DIE

回到女孩类。

定义描述状态的常量
定义初始化常量INIT，初始化为0。
定义前进状态常量FORWARD，初始化为1。
定义后退状态常量BACK，初始化为2。
定义旋转状态常量SPIN，初始化为3。
定义死亡状态常量DIE，初始化为4。

### 属性：status  

定义女孩状态变量status。
生成get方法。

### 属性：invincible

定义描述女孩是否无敌的变量invincible。

### 构造方法：Girl

在构造方法中，将女孩初始位置设置为-100*100，表示一开始女孩在屏幕之外，然后移动到屏幕之中。
另外女孩处于前进或后退状态时，才能发射子弹、才能减道具，

### 操作：keyReleased ---- PressKeyEvent

打开键盘事件处理类。
在发射子弹的业务中，加上女孩状态的判断。
访问女孩对象。访问女孩的状态
如果状态为FORWARD，或者为BACK，才能完成子弹的发射。

### 重写：move

打开道具类。
在道具和女孩碰撞算法中，加上女孩状态的条件判断，并且访问女孩对象。
访问女孩的状态。
如果为FORWARD或者为BACK。在完成女孩和道具的碰撞算法，

由于并且优先级大于或者，所以，把第二个条件括起来。
这样当女孩状态为前进或后退时才能完成捡道具的动作

这一讲，我们完成女孩图片和状态的定义
下一讲，我们完成女孩的动作行为。



# 第28章、女孩行为的定义和图片的设置

上一讲中，我们完成女孩图片和状态的定义，
这一讲我们完成女孩的动作行为，

我们来看一下女孩有哪些动作

### 问题：女孩动作分析

刚开始在屏幕之外，处于初始状态，然后移动到屏幕之中。
初始状态时女孩是不受玩家控制的。然后移动到屏幕中某个位置之后处于正常状态。
这时可以受玩家控制，可以发射子弹、可以捡道具，同时处于无敌状态。

无敌一段时间之后，无敌消失，处于普通正常状态。
这时女孩才能被敌人或敌人子弹打死
正常状态下，按下左键处于后退状态。
正常状态下，按下右键或不按方向键处于前进状态。
当按下炸弹键处于旋转状态。
当女孩被敌人或敌人子弹击中处于死亡状态。

从这里可以看出，女孩动作比较多，每种状态都会执行相关动作和业务处理，

### 问题：（单一职责原则） 描述女孩行为

所以按照单一职责原则，我们应该将不同的状态，需要完成的业务操作独立成方法，然后在move方法中进行调用。
为什么这样干？
我们在实现女孩相关业务时，就可以将对女孩整体行为的描述，变成只关注某一种行为，减少开发难度，

打开女孩类。
创建setImage方法，描述女孩在各种状态下的图片。
创建setInit方法，描述女孩初始状态和行为。
创建setSize方法，描述女孩在各种状态下的大小。
创建setmove方法，描述女孩正常状态移动的行为。
创建setHit方法，描述女孩被敌人或敌人子弹击中的行为。
创建setInvisible方法，描述女孩无敌状态的设置。
创建setSpin方法，描述女孩旋转状态的行为。
创建setDie方法，描述女孩死亡状态的行为。

### 方法：setmove   ----  Girl

很显然，玩家通过键盘，控制女孩的移动，应该放在setmove方法中，将女孩通过键盘移动的代码剪切到setmove方法中。

### 方法：setImage

而描述女孩的图片，应该放在setImage方法中。

这样，我们在实现女孩相关业务时，就可以将对女孩整体行为的描述，变成只关注某一种行为，减少开发难度，

### 重写：move  ----  Girl

然后在move（）方法中对各种状态下业务方法进行调用，实现女孩的业务

在move方法中判断女孩的状态是否为初始状态。
如果为初始状态，调用setInit方法，完成初始状态的动作描述，
如果是旋转状态，调用setSpin方法，完成旋转状态的动作描述，
如果为死亡状态。调用setDie方法完成死亡状态的动作描述，否则在正常状态下调用setmove完成女孩的移动
在调用setSize方法，完成各种状态下女孩大小的描述
在调用setHit方法，完成女孩被敌人或敌人子弹击中的描述，
在调用setInvisible方法，完成女孩无敌状态的描述，

但是，无论在任何状态下都应该有女孩相应的图片绘制，所以在状态判断之后，
再调用setImage方法，完成女孩各种状态下图片的绘制，

### 方法：setImage

我们来实现一下setImage方法
判断女孩的状态。
如果为前进状态，并且无敌状态为真，那么完成无敌状态前进图片的切换，
当女孩状态为前进状态，并且无敌状态为假时，那么女孩的图片在普通状态前进图片数组中切换，
当女孩状态为后退状态，并且无敌状态为真时，当前女孩图片在无敌后退图片之间切换。
当女孩状态为后退状态，并且无敌状态为假时，当前女孩图片在普通状态后退图片之间切换。
在判断状态为旋转时，当前女孩图片切换为旋转图片。
如果女孩状态为死亡，当前女孩图片赋值为死亡图片。

那么，初始状态时的图片，我们也设置为普通状态前进的图片
或者判断当前女孩的状态为初始状态，女孩图片设置完成

测试一下。
将女孩的坐标设置为（300，300）
测试完毕后再改回来

可以看到初始状态下女孩的图片。将状态更改为forward，将无敌状态修改为真。
运行一下。
可以看到，发光的女孩出现了。

将无地状态更改为假，可以看到普通前进状态的女孩出现了。

将状态更改为Back
运行一下。
可以看到普通状态后退的图片出现了。
将无敌状态修改为真。可以看到无敌状态的后退图片出现了。

前进状态和后退状态下都能发射子弹，

将女孩状态修改为旋转。
可以看到旋转状态的图片出现，这时女孩不能发射子弹。

将女孩状态修改为死亡。
可以看到女孩死亡状态出现了，这时也不能发射子弹。

大家自行测试一下各种状态下图片是否正确

这一讲，我们完成女孩行为的定义以及图片的设置，

大家思考一下在女孩后退时、旋转时、死亡时，图片有些畸形，这原因是什么呢？又如何解决呢？
下一讲，我完成女孩初始化动作和一度行为的设置。

# 第29章、女孩初始化动作和移动的设置

大家好，在上一讲中，我们完成了女孩行为的定义以及图片的设置，
不过在女孩后退、旋转、死亡时，图片有些畸形，这原因是什么呢？又如何解决呢？

这一讲我们完成女孩大小、女孩初始化动作和移动的设置。

### 操作：drawMyself ----  BaseRole

打开BaseRole。
在drawMySelf方法中，我们完成的角色图片的绘制。

角色图片的绘制坐标为当前角色的坐标，角色图片绘制的大小为当前角色的大小
在女孩构造方法中，我们完成了女孩宽度和高度的定义，

### 问题：女孩移动为什么会造成图片畸形

在女孩构造方法中，大小初始化为60*40，这是根据前进状态设置的，不过，在女孩后退旋转，死亡等状态下，大小的设置并没有发生变化，还是60 40，由于各种状态下图片的宽度和高度比例不同，所以就造成了畸形

### 问题：在setSize中解决图片畸形问题

### 方法：setSize

解决方案是，在不同的状态下设置女孩的宽度和高度，以适应图片的比例，
我们在setSize方法中判断女孩是否为前进状态。
如果为前进状态，设置宽度为60，高度为40，
如果状态为后退状态，将宽度设置为40，高度设置为60，
如果是死亡状态，将宽度设置为50，高度设置为50
旋转状态下，大小随时在改变，由设置旋转的方法setSpin来描述

### 问题：设置女孩的移动行setmove，移动范围不超出屏幕

### 方法：setmove

我们的完善一下setmove方法，该方法用于描述女孩的移动方式，现在已经实现根据键盘完成控制女孩移动的业务。
不过，如果玩家一直按着某一个方向件，比如一直按着上键或一直按着下键，那么女孩就可能移动到屏幕之外，女孩作为主角应该一直停留在屏幕之中。

我们现在来完成女孩不能离开屏幕的业务。
在向上移动判断中，判断女孩的Y坐标是否小于等于30。
如果满足，表示女孩向上超过屏幕，将Y坐标设置为30

在向下移动的判断中，判断女孩的Y坐标是否大于等于 700减去当前女孩的高度，
如果满足，表示女孩向下超过屏幕，将Y坐标设置为 700减去当前女孩的高度。

在向左移动的业务中，判断女孩的X坐标是否小于零，
如果满足，表示女孩向左超出了屏幕，将X坐标设置为零，同时在玩家按下左键时，将当前女孩的状态，设置为back后退状态，

在向右移动的判断中，判断女孩的X坐标是否大于等于 1000减去当前女孩的宽度，
如果满足，表示女孩向右超出屏幕  将X坐标设置为1000减去当前女孩的宽度，同时设置状态为前进状态。

在玩家没有按下方向键时，默认状态设置为前进状态，
判断PressKeyEvent中的 isRight 变量是否为假，
同时判断PressKeyEvent中的 isLeft 变量是否为假，
如果isRight 和isLeft变量同时为假，表示用户没有按下向左或向右键，那么将状态设置为forward前进状态

测试一下，将状态设置为前进状态，将无敌状态设置为假

可以看到，在按下左键和右键后，女孩大小发生变化，没有造成畸形。
同时，女孩也不能超出屏幕。

有一点需要说明一下。
窗体之中标记栏占的高度是30，所以判断女孩不能向上超出屏幕时，判断的是30而不是0，
现在我们完成女孩初始状态的描述，

将女孩默认的状态设置为INIT，
将女孩的坐标设置为-100*100。

### 方法：setInit

在setInit() 方法中描述女孩初始化行为
将X累加10像素，判断X坐标是否大于等于200，
如果满足，将状态设置为foward的前进状态。
这时可以被玩家控制，同时将无地状态设置为真

### 方法：setInvincible

不过无敌状态不能一直为真，如果一直为真，女孩就打不死了，无敌状态，应该在一段时间之后消失。
创建无敌计数器变量invisiblecount，设置无敌的方法中，描述无敌状态的设置，将无敌计数器加加，当无敌计数器大于200时，也就是4秒钟以后，将无敌计数器归零，同时将无敌状态设置为假。

运行一下。
可以看到，初始状态人的屏幕之中，发着金光表示无敌状态。4秒钟以后无敌状态消失，这时女孩为普通状态。

这一讲，我们完成的女孩大小、女孩初始化动作和移动的设置。

另外再按一下炸弹节以后，女孩要完成发大的动作，大家可以先自己实现一下，现在讲我们来看一下如何实现女孩发大招。



# 第30章、女孩发大招

上一讲中，我们完成女孩大小、初始化动作和移动的设置
这一讲我们完成女孩发大招

大招是在按下炸弹键以后触发的，
我们应该在键盘事件处理类中定义

打开键盘事件处理类在谈起事件中判断键盘吗？
是否为S键。
如果为S键完成女孩发大的动作，

### 方法：setSpinInit  ---- Girl

打开女孩类。
定义setSpinInit方法，完成旋转初始化的定义。

### 操作：setSpinInit ----  PressKeyEvent.keyReleased

回到键盘事件处理当玩家弹起S键以后，
访问女孩对象，调用女孩的setSpinInit的方法，完成旋转的初始化，

### 方法：setSpinInit

回到女孩类
在setSpinInit方法中完成旋转初始化的定义。
判断女孩状态是否为前进和后退状态。
只有这两种状态，女孩才能发大招。

同时女孩还得有炸弹才行，加上条件判断。
判断bombNumber属性是否大于零，
如果满足表示女孩有炸弹

由于并且优先级高于或者，所以将第一个条件括起来，

将状态设置为旋转状态，同时将当前女孩的炸弹数量减一。
设置女孩旋转初始大小，宽度设置为40、高度设置为65

旋转状态的初始化完成的，现在我们完成旋转的动作、女孩的旋转行为。
我们让女孩变大到一定程度以后再变小，
变大到一定程度时，状态恢复正常状态，同时处于无敌状态。

### 属性：spincount  ----  Girl

定义女孩旋转计数器属性spincount。

### 方法：setSpin

在描述旋转的方法setSpin中完成旋转的行为
首先将旋转计数器spinCpunt加加
判断spincount是否小于50，如果满足将女孩变大
将女孩的宽度累加4个像素、高度累加4个像素，
如果spincount大于等于50，并且小于100，
那么将女孩宽度累减4个像素、高度累减4个像素，
当旋转计数器大于100时将旋转计数器归零。
同时，将状态设置为女孩的前进状态
将无敌变量invincible设置为真。
同时将无敌计数器变量，invinciblecount归零

女孩旋转行为描述完成
测试一下。

正常状态时按下S键。可以看到女孩旋转起来，
先变大再变小，同时处于无敌状态，旋转动作完成。

### 问题：大招需要具备攻击性（依赖倒置原则）

不过，女孩发大招需要具有攻击性，
我们设定女孩发大招时所有怪物生命减少100
同时清除屏幕中的敌人子弹，

所以应该将该业务写在setSpinInit方法中，
在大招发出以后。遍历角色，集合。
在循环体中取出角色对象。用变量role接收。

### 问题：大招攻击时需要考虑到哪些问题

按照依赖倒置原则判断，role变量是否匹配怪物类型。
如果匹配，将role变量强转为怪物类型，用变量enemy接收
调用enemy.byHit方法，减少怪物生命，传入100，表示每个怪物减少100点生命
不过当怪物生命减少为0时，怪物对象会自动从角色集合中移除。
那么，这意味着角色集合长度随时在变化，
所以需要加上一个判断，
当生命减少为100时，将循环变量i自减，否则很可能会漏掉一些角色的判断。

### 方法：getHp ---  EnemyRole

在怪物父类enemyRole中生成生命属性的get方法。

### 方法：setSpinInit  ---  Girl

回到女孩类。判断怪物生命是否小于零。
如果满足表示怪物被打死，将循环变量i自减。

运行一下。
征程状态时按下S键。
机器狗、灯怪都被打死的。

这一讲，我们完成的女孩发大招

大家思考一下
如何完成敌人子弹的清除。
另外，女孩还需要撒下满天的花瓣，
大家可以自己先实现一下，
下一讲，我们完成敌人子弹的清除以及女孩撒花瓣的业务。

# 第31章、女孩撒花瓣

大家好在上一讲座，我们完整的与和的发达着，同时完成的女孩大大着死，对敌人生命的减少。另外女孩发文打折以后需要完成顶子弹的清楚，同时还需要撒下满天的花旦，这一讲我们完成敌人子弹的清楚，以及与和撒花不了业务，我们先完成敌人子弹的，清楚地因子，但都几水杯是住角色，父类那么，如何判断当前角色是顶子弹呢？当然，我们可以像怪物一样抽象一个敌人子弹的父类，但是该父类没有敌人子弹共同的特征和行为，所以最好世界一个标识性接口。
该接口中可以不得以任何方法，但是，19敌人子弹类必须实现该接口一个接口中没有任何方法，实现该接口有什么意义呢，义在于，只要一个类实现的。该接口。那么按照多态的定义就可以使用该接口变量引用该实现类对象。同时由于该类是集合时间类也可以通过医生说，五匹配该集合类型在JAVA点，I O包中有一个序列化接口，也是没有定义任何方法的标志性接口，但是，还是要小需要进行传输的类实现该接口，从而实现多态的引用。在角色包装。
新建标识性接口，ADB波莱特。打开火球类，将火车类实现敌人子弹第一次性接口打开女孩类在写的是B英力特中加上调节判断，如果当前角色匹配敌人子弹类型。从角色集合中移除子弹对象。同时，将I减减避免漏掉判断测试一下。正常状态是按一下S店。可以看到机器狗和灯怪都被打死的。红色非要出现了。按下S键可以看到红色，非个发射子弹消失。现在我们来完成女孩撒花瓣的业务，首先在角色包装，新建花瓣类负大二。基层杯摄入。添加构造方法。
重写目录方法，花不了图片，一个有两张。否则，2点拼劲，这是普通话，但。肉质点拼劲，这是玫瑰花，但所以应该在花瓣那中创建两个图片，数组，新建普通花旦图片数组。弗莱尔一迈进。在新建玫瑰花瓣图片数组。ROLLS1迈进。打开英力特一脉基类，在阴历的方法中完成完成花旦图片的初始化访问普通花瓣数组调用卡特尾卖，记得卡特，然后一买几方法？传入图片，路径。传入七哥图片数吧，媒体跟踪器以及媒体跟踪器的分组。在访问玫瑰花瓣数组，调用卡特一脉，记得卡特100G方法传入玫瑰花瓣的图片路径。
传入切割图片数四传入媒体跟踪器以及媒体跟踪器的分组。回到花瓣类。由于花瓣有两种普通花旦以及为规划，但所以创建两个代表花旦类别的常量。螺母初始化为零表示，普通花瓣类型。在定义常量。绕着初始化唯一表示玫瑰花瓣类型。第一属性TYPE表示当前花不了类别。在构造方法中添加形参类别。并完成对属性TYPE的初始化。另外，我们还需要定义花瓣的移动方向化笨的移动方向有两个左下方像和忧伤方向定义左下方，像产量。雷夫当初始化为零。
DE有上方向产量。亚太APP，初始化唯一。定义花瓣移动方向属性，因为可信。在构造方法中添加方向形参。并完成对属性敌人核心的初始化。DE图片切换对象避难比设置为将G O B J。切换频率低，意味三。在构造方法中，需要完成花瓣坐标和大小初始化花瓣的坐标和大小都采用随机数实现删除形参大小和做不了定义花瓣的X坐标定义为100到900之间，书写慢4点染懂审议800再加上100强转为整型。花瓣的Y坐标第一位，第一晚100到600之间书写曼斯点染懂审议500再加上100强转为整形。
花瓣的宽度定义为50到100之间书写曼斯点懂神医50再加上50强长整型。花瓣的高度应该和宽度椅子不能采用随机数才用随机数可能会长花瓣的高度和宽度比例失衡，将高度初始化为零在构造方法中将高度的值赋值为宽度的值，这样保证，每个花瓣对象宽度和高度一致。在目录方法中，先完成图片的切换。判断花瓣的类型。如果为普通话，但。调用将G O B界的降级方法传入普通花旦图片数组。完成普通花瓣，图片切换，并对属性优异卖给赋值，如果是玫瑰花瓣。
那么，切换玫瑰花瓣图片数组。现在完成花瓣的移动判断花瓣的移动方向。如果是左下方向。将X坐标没减，一个随机的移动速度最小值涉水四最大值涉水11书写曼斯点染懂审议吧，再加上四将Y坐标累加4到11之间的随机数。如果是有上方向。将X坐标累加是的，11的随机数。将Y坐标理解是的，死一的，数一数，打开女孩类。在C的是比INT旋转初始化方法中完成花瓣的产生。书写负循环产生40个左向和有上的普通话半。在角色给盒装添加花瓣对象传入类别，普通花瓣传入三，向左下方像。
在角色集合中添加花瓣对象传入花瓣的类别，为普通花瓣传入方向为业务上方向，这样一共产生的40个左下方向的普通话，但以及40个有上方向的普通话，但在书写负循环产生15个左下颌有上的玫瑰花，但在书写负循环产生15个左下和业务上方向的唯一规划，但在角色集合中添加花瓣对象类别设置为玫瑰花瓣方向设置为左下方像在角色集合中，在添加花瓣对象类别设置为玫瑰花瓣方向设置为右上方像，这样同时产生的15个左下方见的玫瑰花，但以及右上方新的玫瑰花瓣运行一下。
按一下炸弹见。可以看到产生了满天的花旦。不过，花瓣虽然产生的，但效果似乎并不太好。首先每个花瓣的速度似乎都一样月一次，我们在模糊方法中产生的随机速度，而目方法在线程中调用每个20毫秒调一次这样也就意味着每个20毫秒会产生一个新的手机速度一块块一会儿，慢整体算下来，每个花瓣速度就差不多了。解决方案是在构造方法中产生随机速度，对于一个对象而言，构造方法在整个生命周期中自信一次也就是说产生的随机速度，在运行过程中不会发生变化，将可以解决花旦一度，速度问题。
在花瓣了一中创建速度属性斯P的。在构造方法中，完成审批的熟悉的初始化将是P的初始化为4到11的，数一数。在目录方法中，将花瓣移动速度更改为四批的属性。另外，每个花瓣同时显示的图像是椅子的原因是在图片切换对象一般相机中下标都是从零开始的，这样每个花瓣对象都从第一张图片开始切换同时显示的图像。当然是一样的，我们可以从在一个构造方法。除了定义频率，行在以外，再加上一个即使下个形参index在构造方法中完成频率和其实下标的初始化。
打开花瓣类将图片切换对象的变量，名更改为辐照降解，这是切换普通花瓣的图片切换对象。普通花旦是吧？张图片切换图片的起始下标设置为0到7的随机数。在定义图片切换对象变量名秘密为肉质呛进这是切换违规花瓣的图片切换对象切换频率第一，为五玫瑰花瓣是四张图片切换，其实下标定义为0到3的随机数。将摸摸方法装图片切换对象进行更改。一下。按一下查战舰。可以看到花瓣的速度和图片切换的，其实下标发生了变化，显得错落有致。
好，这一讲，我们完成的，与和撒花不的业务下一讲我们完成女孩火力增强的业务。

# 第32章、发射菱形飞镖

大家好，再三一点钟，我们完整的女孩撒花瓣的业务，这一讲我们完成女孩火力增强的业务在女孩捡到火力道具以后需要完成女孩火力的增强，增强的方式有两个可以发射斜向的林系非标。另外要产生宠物貂宠物，貂可以吐火攻击敌人。这一讲我们主要完成零星飞碟的产生。首先，我们需要在女孩那种B1个宠物貂的变量腹水空在女孩捡到火力道具以后再完成宠物貂的实例化，然后根据女孩的宠物貂属性是否为空来判断是否应该发射临近非标在角色包装，新建宠物貂类，命可继承杯思路添加构造方法。
重写目录方法，三组第一的形参将其实坐标设置为零道理，初始大小设置为445项，25宠物貂相关的业务，我们在后面实现打开女孩类。利益宠物貂属性命可。3层地的方法。在增加火力方法，也是怕中，完整宠物貂属性的实例化在角色包装新建临行非标类部门改革。继承北驶入。添加构造方法。从写木方法。定义零星非标图片数组博物院个100G。林姓非标，采用J波利特中的。圆饼可电拼劲。打开英力特100几类完成零星非标图片的初始化访问零星非标的图片。
调用卡特以面积的看的100及方法传入图片路径。传入切割图片数三传入媒体跟踪器以及媒体跟踪器的分组。回到理性，非标类定义，零星非标的移动方向零星非标移动方向有两个友善方向和右下方向DE有上方向产量。亚太APP，初始化围篱。定义右下方像常量WRITE，但说实话我一。定义零星背标移动方向属性，第二可惜。在构造方法中定义方向形参，并完成对属性第二可行的初始化。定义图片切换算法工具对象变量比秘密为将G O B J。
切换频率定义为二。零星非白大小设置为四十三四十。林心非标的起始位置和女孩儿有关。其次，X坐标设置为与还X坐标加十个像素访问互联网中的女孩子对象。访问X坐标加上4个像素访问FRAME中的女孩对象。在点Y坐标加上4个像素删除坐标和大小形态的定义。在方法中完成零星非标移动的描述首先进行图片切换。调用将G O B J的相机方法传入临性非标图片数组。完成林心非标图片切换判断当前临行非标的移动方向。如果为有上方向。
那么，将X坐标累加15个像素Y坐标理解五个像素。如果是有下方向。将X坐标累加15个像素将Y坐标累加五个像素当离析非标几种怪物以后，怪物需要减少生病，同时产生肌肉效果遍历角色集合。在循环体中取出角色对象。用变量肉接收判断，当前林兴非标是否和角色相碰，调用当前零星非标的碰撞区域在点INTERFACE方法传入角色的碰撞区域。如果几种角色，并且角色匹配怪物类型。表示零星非标激动怪物将U变量将转为APP助怪物类型。
用变量APP接收调用ADB的白克的方法传入20表示林异性非标几种怪物后，减少20点生比现在添加肌肉效果在角色集合中添加几种的小报的对象，布拉斯特其实位置坐标设置为临行非标的X坐标加上40像素。其实，Y坐标设置为当前，林心非标的Y坐标。同时从角色集合中移除当前，临行非标对象打开键盘事件处理类。在产生子弹的业务中。加上判断访问对象在访问宁可属性如果命可属性不得光表示该女孩已经做了火力增强那么在角色集合中添加有上方向的临行非标。
在添加。右下方向的离析非标。

测试一下。打死灯怪捡到到火力道具。
可以看到菱形飞镖产生，
这一讲我们完成的菱形飞镖的发射

从下一讲开始，我们完成宠物貂的业务。

# 第33章、初始化宠物貂信息

大家好，在上一讲中，我们完成菱形飞镖的发射
从这一讲开始，我们完成宠物貂的业务。

### 问题：分析宠物貂状态变化

首先我们来看一下宠物貂的图片，宠物貂一共有四张图片，
分别是普通动作连图，消失动作连图，准备吐火动作连图以及吐火的动作连图 
四张图片分别对应宠物貂的四种状态，
普通状态、消失状态、准备吐火状态，以及吐火状态。

我们先对宠物貂的状态进行定义，然后通过一系列事件，改变宠物貂的状态，

我们来看一下宠物貂的产生以及状态的变化，
在女孩捡到火力道具以后产生宠物貂，默认处于普通状态。一直跟在女孩之后。

按下开火键，开始聚气，聚气到达一定程度之后，宠物貂处于消失状态，
持续的聚气，宠物貂处于准备吐火状态

宠物貂一直在女孩之前并随着主角移动。
然后，弹起开火箭，宠物貂处于吐火状态，这时不再随女孩移动，持续吐火攻击怪物，
在吐火一段时间之后，回到普通状态。

这一讲我们完成宠物貂图片的初始化以及状态的定义

### 属性：宠物貂的状态图片数组  （4种）---- Mink

打开宠物貂Mink类，
定义普通状态图片数组，normalImage。
定义消失状态图片数组，disappearImage
定义准备吐火图片数组，readyFireImage。
定义吐火状态图片数组，fireImage

### 方法：initMinkImage ---  InitImage

打开InitImage类，在init方法中，完成宠物貂图片的初始化，

由于宠物貂图片很多，所以最好独立成方法。

定义initMinkImage，完成宠物貂图片的初始化定义，形参为媒体跟踪器。
在init方法中完成宠物貂图片初始化方法的调用，传入媒体跟踪器。

我们先完成宠物貂普通状态图片的初始化访问
宠物貂普通图片数组normalImage，
调用CutImage.cutOneImage方法，传入图片路径，传入切割图片数2，传入媒体跟踪器以及媒体跟踪器的分组。

完成宠物貂消失状态图片数组的初始化，
调用CutImage.cutOneImage方法，传入图片路径，传入切割图片数4，传入媒体跟踪器以及媒体跟踪器的分组。

完成宠物貂准备吐火状态图片数组的初始化
调用CutImage.cutOneImage方法，传入图片路径，传入切割图片数6，传入媒体跟踪器以及媒体跟踪器的分组。

完成宠物貂吐火状态图片数组的初始化
调用CutImage.cutOneImage方法，传入图片路径，传入切割图片数8，传入媒体跟踪器以及媒体跟踪器的分组。

### 属性：宠物貂状态常量（4种）  ----  Mink

回到宠物貂类
定义描述状态的常量，
定义普通状态常量，NORMAL初始化为0。
定义消失状态常量，DISAPPEAR初始化为1。
定义准备吐火状态常量，READYFIRE初始化为2。
定义吐火状态常量，FIRE初始化为3。

### 属性：status ---- Mink

定义宠物貂状态变量，status初始化为NORMAL普通状态。

### 操作：ImageChange

定义图片切换对象ImageChange，变量名设置为changeObj，切换频率设置为4。

### 构造方法：Mink

宠物貂初始状态为普通状态，起始位置设置为女孩的左上角，
定义X坐标为女孩X坐标减去35像素，
访问GameStartFrame中的女孩对象，在访问其X属性，减去35像素，作为宠物貂初始的X坐标
宠物貂初始的Y坐标设置为女孩Y坐标减去15像素，
访问GameStartFrame中的女孩对象，访问其Y属性，减去15像素，

宠物貂默认为普通状态，初始大小设置为45*25

这一讲我们完成宠物貂图片和状态的定义
下一讲，我们完成宠物貂的动作行为。

# 第34章、设置宠物貂图片和移动方式

大家好，在上一讲中，我们完成宠物貂图片和状态的定义，
从这一讲开始，我们完成宠物貂的动作行为。

### 问题：(单一职责原则)宠物貂状态的变化

我们再来看一下宠物貂状态的变化。

在女孩捡到火力道具以后产生宠物貂，默认处于普通状态，这时一直跟在女孩之后。

按下开火箭不放，开始聚气，在聚气到达一定程度之后，宠物貂处于消失状态，
持续的聚气让宠物貂处于准备吐火状态
宠物貂移动到女孩前面并随着女孩移动。
然后，弹起开火键，宠物貂处于吐火状态。
这时不再随女孩移动，持续吐火攻击怪物，
在吐火一段时间之后回到普通状态。

宠物貂动作比较多，按照单一职责原则，应该将不同状态需要完成的业务操作独立成方法，
然后在move方法中进行调用，

在宠物貂Mink类中

创建setImage方法描述宠物貂在各种状态下的图片。
创建setmove方法描述宠物貂的移动行为，
创建setStatus方法描述宠物貂状态的变化。

### 重写：move ---- Mink

在move方法中，描述宠物貂的行为，
先调用setStatus方法，完成状态的设置
在调用setmove方法，完成宠物貂移动的行为，
在调用setImage方法，完成宠物貂各种状态下图片的设置

这一讲，我们完成宠物貂图片的设置以及移动方式的设置

### 方法：setImage  ----  Mink

先完成宠物貂图片的设置，
在setImage方法中判断宠物貂的状态。
如果状态为普通状态。那么切换普通状态图片数组，宠物貂的宽度设置为45，宠物貂的高度设置为25。
如果宠物貂状态为消失状态。那么切换消失的动作连图，宠物貂的宽度设置为45，宠物貂的高度设置为25，
如果宠物貂状态为准备吐火状态。那么切换准备吐火状态的动作连图，将宽度设置为100，高度设置为100，
如果宠物调状态为吐火状态。那么切换吐火状态的动作连图，将宠物貂的宽度设置为150，高度设置为80

宠物貂图片设置完成，

### 方法：setmove  ----  Mink

现在我们完成宠物貂移动行为
setmove方法中判断宠物貂的状态。

如果宠物貂状态为NORMAL普通状态，或者是消失状态。
设置宠物貂在女孩的左上角，并跟随女孩移动，
设置宠物貂的X坐标，访问GameStartFrame中的女孩对象，在访问其X属性，减去35像素，
设置宠物貂的Y坐标，访问GameStartFrame中的女孩对象，在访问其y属性，减去15像素，

如果宠物貂为准备吐火状态。
设置宠物貂在女孩右上角，并跟随女孩移动
设置宠物貂的X坐标，访问GameStartFrame中的女孩对象，在访问其X属性，加上80像素，
设置宠物貂的Y坐标，访问GameStartFrame中的女孩对象，在访问其Y属性，减去80像素，

吐火状态下，宠物貂不会移动，同时不受女孩和玩家控制
在setmove方法中不用描述

### 方法：addPower  ----  Girl

打开女孩类
在女孩捡到火力道具以后，对Mink宠物貂属性实例化，同时将宠物貂加入角色集合。

由于一个女孩只能产生一个宠物貂，所以在添加至角色集合之前，先判断mink属性是否为空。

如果mink属性为空，在将宠物貂添加至角色集合，
判断，如果mink属性为空时，在完成mink属性的实例化，并在角色集合中添加宠物对象。

运行一下。
捡到火力道具。
产生宠物貂，这是普通状态的宠物貂。
可以看到跟随着女孩移动。

将宠物貂初始状态修改为消失状态。可以看到消失状态图片出现的。
消失状态时宠物貂也跟随女孩移动。

在将宠物的状态修改为准备吐火状态。
可以看到准备吐火状态时，宠物貂在女孩的右上方。

在将从调状态修改为吐火状态。
并在构造方法中，将坐标设置为300*300。
可以看到宠物貂吐火图片出现了。

重新将宠物貂状态修改为NORMAL普通状态，删除宠物貂坐标的赋值

这一讲，我们完成的宠物貂图片和移动方式的设置
下一讲，我们完成宠物貂状态的设置。

# 第35章、宠物貂状态设置

大家好在上一讲中，我们完成的宠物貂图片和移动方式设置
这一讲完成宠物貂状态的设置。

### 属性：isFire  ---  PressKeyEvent

宠物貂状态的变化是根据玩家按下了开火箭聚气而触发的
打开键盘事件处理类PressKeyEvent
定义isFire变量，用于描述玩家是否按下开火箭。

### 操作：keyPressed  --- PressKeyEvent

在键盘按下事件中判断键盘码，是否为A开火箭。
如果玩家按下开火键，
将isFire赋值为真，

### 操作：keyReleased  --- PressKeyEvent

在键盘弹起事件中如果玩家松开开火键，将isFire赋值为假

### 属性：gathercount ---- Mink

打开宠物貂类。
由于聚气需要一定时间
所以我们在宠物貂中创建聚气计数器变量gathercount

### 方法：setStatus ---  Mink

在setStatue方法中描述宠物貂状态的变化

判断PressKeyEvent的isFire变量，如果为真，并且状态为普通状态时，表示玩家在宠物貂普通状态时聚气
将gathercount聚气计数器变量自增，当聚气计数器变量大于100时。
将状态设置为消失状态。

判断PressKeyEvent的isFire变量，如果为真，并且状态为消失状态时，表示玩家在宠物貂消失状态时聚气
将gathercount聚气计数器变量自增，当聚气计数器变量大于等于116时。
将状态设置为准备吐火状态。

如果聚气时间不够，退回普通状态

如果宠物貂状态为吐火状态，这时不受玩家和女孩控制，
同时在吐火一段时间之后会消失。
创建吐火计数器变量firecount。
在吐火状态时将firecount自增。
当firecount大于200时，设置吐火结束。
将状态设置为普通状态
同时将firecount计数器归0，

书写else，将firecount计数器归0

# 第36章、宠物貂吐火

上一讲中，我们完成宠物貂状态的设置
这一讲，我们完成宠物貂吐火的业务

当宠物貂在吐火状态时，
应该在宠物貂里面产生火的对象，并且火可以攻击敌人。
所以我们应该新增一个火类，
在准备吐火状态转化为吐火状态时，
在角色集合中添加火的对象，
并在吐火状态结束时从角色集合中移除火对象

### 新建类：Fire

在角色包中，新建一个火类Fire。
继承BaseRole，添加构造方法。重写move方法。

### 属性：fireImage 

创建图片数组fireImage。

### 操作：CutImage.cutOneImage  --- InitImage.init

打开InitImage类，完成火图片的初始化
访问火类中的火图片数组，调用CutImage.cutOneImage方法
传入图片路径，传入切割图片数6，传入媒体跟踪器以及媒体跟踪器分组。

### 操作：ImageChange  --- Fire

回到火类。
定义图片切换对象ImageChange，变量命名为changeObj，切换频率为3。

### 构造方法：Fire

在火的构造方法中完成坐标和大小的初始化
大小初始化为200*120，坐标应该是宠物貂吐火状态的坐标，应该传递过来，删除大小形参的定义

### 重写：move ---  Fire

在move方法中完成火行为的描述，
首先完成图片切换，调用changeObj的change方法传入火图片数组，并完成对属性roleImage的赋值

火对象有攻击敌人的行为
遍历角色集合。
每循环一次取出角色对象，用变量role接收
判断当前火对象的碰撞区域是否和角色相交，
调用当前对象rect属性的intersects方法，传入角色的碰撞区域，
如果为真，表示火对象击中了角色，
并且判断角色是否匹配怪物类型。
如果匹配表示火对象击中了怪物。
将角色强转为怪物类型。
用变量enemy接收

调用enemy.byHit方法减少怪物生命，传入减少生命数三，看起来比较少，
但是在吐火状态下，火对象是不消失的，也就是每20毫秒减少3点生命，攻击力是很高的。

现在我们完成火对象的添加和移除

### 属性：fire --- Mink

打开宠物貂类。
创建火对象的属性fire，表示宠物貂吐火对象。

### 操作：setStatus ---  Mink

在准备吐火状态转化为吐火状态时将fire实例化。
起始坐标设置为当前宠物貂坐标的右上角，
X坐标设置为当前宠物调坐标加上150像素
Y坐标设置为当前宠物貂Y坐标减去50像素，
并在角色集合中添加火对象。

在吐火结束时从角色集合中移除当前宠物貂的火对象。
同时将fire属性设置为空。

### 方法：getFire

为了在别的类访问火对象，将火对象生成get方法。

测试一下。

捡到火力道具。
按下开火键聚气，聚气满了以后松开开火键吐火。
可以看到火对象产生，并且可以攻击敌人。

吐火结束后，火对象消失，如果还要吐火需要重新聚气。

这一讲，我们完成的宠物貂吐火的业务
下一讲我完成女孩死亡的业务。

# 第37章、女孩死亡

上一讲，我们完成的宠物貂吐火的业务，
这一讲我们完成女孩死亡的业务，当女孩被敌人或怪物子弹击中后，将处于死亡状态，
女孩被敌人或敌人子弹击中，需要三个条件，
一、女孩的碰撞区域和敌人或敌人子弹碰撞区域相交
二、女孩处于正常状态，也就是前进或后退状态。如果女孩已经死亡，不能再次死亡，游戏不提供鞭尸的业务
三、女孩不处于无敌状态。

我们先来完成女孩被敌人或敌人子弹击中的业务

### 问题：女孩被击中的业务

### 方法：setHit --- Girl

打开女孩类
在setHit方法中完成女孩被敌人或敌人子弹击中的描述
遍历角色集合。
在循环体中，从角色集合中取出角色对象。用变量role接收。
判断当前女孩对象是否和角色对象相碰，访问女孩对象的rect属性，
调用intersects方法，传入角色的碰撞区域，结果为真，表示女孩和角色相碰
判断角色是否为敌人或敌人子弹，
加上第二个条件，role instanceof EnemyRole，表示角色匹配怪物类型或者角色匹配敌人子弹类型
表示敌人或敌人子弹击中了女孩。
由于并且优先级高于或者，所以需要括起来。

判断女孩是否为无敌状态
判断invincible变量是否为假，如果为假，表示女孩不是无敌状态，另外女孩是正常状态才能被敌人或敌人子弹击中，
不过在这里不用再书写判断，原因是在move方法中，
如果女孩是初始状态，那么调用setInit方法，
如果是旋转状态。那么调用setSpin方法，
如果是死亡状态，调用setDie方法。
只有正常状态，才会执行setHit方法，
所以能执行setHit方法表示女孩已经是正常状态了，

回到setHit方法，在女孩满足被击中条件时，将状态设置死亡状态。
不过，如果这时女孩已经减到火力道具，已经产生了宠物貂
那么当女孩死亡以后，宠物貂应该移除
不然女孩死亡以后，宠物貂还会出现在屏幕上。
另外，如果宠物貂还在吐火，那么也需要移除火对象。

判断mink属性是否为空。
如果部位空，表示已经产生宠物貂对象，
判断mink属性对象的fire属性是否为空，
如果不为空，表示宠物貂正在吐火，那么先从角色集合中移除火对象。
然后在移除宠物貂对象。

只要女孩被击中，那么马上处于死亡状态，所以后面的角色就可以不用判断了
书写return，跳出方法

女孩被击中的行为描述完成。

### 问题：女孩死亡的业务操作

现在我们来看一下女孩死亡需要做什么样的业务操作
女孩死亡以后，应该一直向下掉，这时不再受玩家控制，超出屏幕以后，应该将生命数减一
如果生命数减少为零，那么游戏通关失败。应该结束游戏。
如果生命数大于0，那么产生新的主角女孩。

### 方法：setDie --- Girl

在setDie方法中描述女孩死亡的业务，
将Y坐标累加25像素，表示女孩一直向下移动。
判断Y坐标是否大于等于750，如果满足，表示女孩已经向下超出屏幕，将女孩的生命数girlNumber减一。
判断girlNumber是否为零。
如果为零，表示通关失败，这时应该结束游戏
访问GameStartFrame中的isRun变量赋值为假，表示终止线程运行，否则，如果girlNumber不为0，那么应该产生新的女孩对象，
不过现在在角色集合中还存在死亡的女孩对象，所以应该先将死亡的女孩对象从角色集合中移除，访问角色集合。调用remove方法移除GameStartFrame中的女孩对象。

访问GameStartFrame中的女孩变量。赋值为新的女孩对象，并在角色集合中添加新产生的女孩对象。，

女孩死亡业务描述完成
测试一下。
在女孩被敌人或敌人子弹击中之后处于死亡状态。
如果生命值大于零，产生新主角。
生命数小于零时，线程停止运行，窗体停止绘制，游戏结束。

这一讲，我们完成女孩死亡的业务下一讲我们完成游戏的通关和游戏的失败业务。

# 第38章、游戏通关和游戏失败

我们完成了女孩死亡的业务，
这一讲我们完成游戏的通关和游戏的失败业务

### 问题：游戏结束情况分析

游戏结束，有两种情况，游戏通关和游戏失败，当打死游戏最后的boss，游戏通关，我们可以设置一个通关窗体描述通关的画面。
当主角女孩被打死，生命检测到0时，游戏通关失败。我们可以设置一个通关失败窗体描述通关失败的画面

游戏通关图片在image文件夹中，该图片是一个动作连图。应该先将该图片进行切割，然后在窗体中进行图片切换，
游戏失败，图片在image文件夹中，该图片是一张图片，不用做图片切割。

我们先在窗体包中新建通关窗体SuccessFrame。

在新建通关失败窗体LoseFrame。

### 操作：setResizable ----  GameStartFrame

打开游戏主窗体类GameStartFrame。
设置窗体大小不能改变，否则很可能出现白边影响游戏的美观。
在构造方法中，调用setResizable方法，传入false，表示窗体不能改变大小。

### 重写：run ---- GameStartFrame

在线程的run方法中，循环绘制游戏中的角色，
不过，在循环条件isRun为假时表示游戏结束，应该停止角色绘制进入通关窗体或通关失败窗体。
调用游戏主窗体的dispose方法，卸载游戏主窗体。

判断通关变量isPase是否为真，当isPass为真时，表示游戏通关成功，那么产生SuccessFrame游戏通关窗体。
否则，当通关失败时。产生LoseFrame游戏通关失败窗体。

现在我们来完善这两个窗体

### 新建类：SuccessFrame

让SuucessFrame继承JFrame，实现Runnable线程接口
重写run方法。

### 构造方法：SuccessFrame

创建构造方法。
先完成窗体信息的设置
设置窗体大小，大小设置为950*700。
设置窗体可见程度。
设置窗体关闭后程序结束。
设置窗体居中显示。
设置窗体大小不能改变
定义memoryImage属性，表示双缓冲画布。
定义memoryGraphics属性，表示双缓冲画笔。
在构造方法中，调用createImage方法，创建950*700的类存画布，并对memoryImage赋值。
调用memoryImage的 getGraphics方法得到双缓冲画笔，并对属性memoryGraphics赋值。

创建线程对象，用变量Thread接收，传入当前对象，
表示线程启动后调用当前类中的run方法，
调用start方法启动线程

### 属性：isRun ---  SuccessFrame

定义isRun属性赋值为真，用于控制线程中窗体的位置。

### 属性：successImage

定义通关图片数组successImage。

### 操作：CutImage.cutOneImage  --- InitImage.init

打开initImage，在initial（）方法中完成通关图片初始化，访问通关窗体中的图片数组对象，调用 CutImage的 cutOneImage方法，传入通关图片路径，传入切割图片数2，传入媒体跟踪器以及媒体跟踪器分组。

### 操作：ImageChange --- SuccessFrame

回到通关窗体。
定义图片切换对象，变量名设置为changeObj，切换频率定义为5。

### 重写：run --- SuccessFrame

在线程中书写while循环，循环条件设置为isRun，
在循环中调用sleep方法，休眠20毫秒。

### 方法：drawFrame --- SuccessFrame

创建drawFrame方法描述窗体的绘制，
定义形参Graphics，变量名设置为g 传入窗体画笔，
在线程中调用drawFrame方法传入窗体的画笔。

在drawFrame方法中，
调用changeObj的 change方法传入通关图片数组。用变量image接收。
调用双缓冲画笔的drawImage方法传入image，
设置坐标（0，0），大小不用设置，默认图片为原始大小900*700，传入空值，表示在类存中绘制
调用窗体画笔，变量g的drawImage方法，传入双缓冲画笔，
绘制位置设置为（0，0），绘制地点设置为this，当前窗体对象，表示将类存图片绘制在当前窗体中

### 问题：在窗体中绘制一些文字

当然，大家也可以在绘制一些文字。比如，恭喜通关，你拯救了王国等等

通关窗体完成。

### 新建类：LoseFrame

我们在来完成通关失败窗体LoseFrame
由于通关失败窗体只有一张图片，所以可以直接用标签实现，不用开启线程绘制窗体
把LoseFrame继承JFrame，

### 构造方法：LoseFrame

创建构造方法，完成窗体信息的设置，
设置窗口大小
设置窗体可见程度。
设置窗体关闭后程序结束。
设置窗体居中显示。
设置窗体大小不能更改
在显示窗体之前创建JLabel标签对象，用变量label接收。传入ImageIcon对象，传入图片路径。

将标签对象加入窗体，窗体默认为边框布局，所以在整个窗体中都会显示图片标签

测试一下。
先将boss打死。可以看到进入了通关窗体，为了测试方便，boss的生命值设置的比较低，打死boss以后进入了通关窗体。

在运行一下。
将女孩生命减少为零。
在女孩生命减少到0时，进入了通关失败窗体，
这一讲我们完成的游戏通关窗体和游戏失败窗体的实现。
下一讲，我们完成游戏菜单窗口实现。

# 第39章、游戏菜单窗体

上一讲我们完成了游戏通关窗体和游戏失败窗体的实现
这一讲我们完成游戏菜单窗体的实现，在玩家开始游戏时，进入的并不是游戏主窗体，而是游戏菜单窗体。

### 问题：分析菜单窗体的功能

在游戏菜单窗体中，玩家可以选择游戏开始、排行榜以及游戏结束，

玩家可以通过光标定位选项，通过上下键改变光标的位置，
按下回车键以后执行玩家选择的功能。

### 新建类：MenuFrame

在窗体包中，新建菜单窗体类MenuFrame，继承JFrmae。

### 构造方法：MenuFrame

创建构造方法，首先完成窗体信息的设置
设置窗体大小，窗体大小设置为950*700。
设置窗体可见程度
设置窗体关闭后程序结束。
设置窗体居中显示。
设置窗体大小不能改变。

在显示窗体之前设置布局管理器为空布局，也称为绝对布局，
利用组件的位置和大小定义窗体中的组件
先创建背景标签图片
创建JLabel标签对象，用变量backImageLabel接收。
传入ImageIcon图片对象，写入图片路径。

设置标签的位置和大小。标签位置设置为（0，-30），标签大小设置为950*700
也就是将该标签占满整个窗体，将标签对象加入窗体，

在创建光标图片标签。
这里需要注意一下，GUI窗体中的组件采用先进先出、后进后出的原则，也就是后加入的组件在下层，先加入的组件在上层
那么很显然，光标图片应该在背景图片之上，
所以，在创建背景图片之前，创建光标图片。

创建JLabel标签对象，用变量cursorLabel接收。
（注意此处是用cursorLabel变量接收，而不是新建一个cursorLabel标签对象，若新建一个cursorLabel变量，运行时会报空指针错误）
传入new ImageIcon对象， 写入图片路径
调用setBounds方法设置标签的位置和大小
将标签加入窗体

### 方法：main

书写main方法。
在main方法中创建MenuFrame游戏菜单窗体对象
运行一下。
可以看到背景图片和光标图片都显示出来。

### 属性：item

实现光标移动效果

标签起始位置为游戏开启选项。
我们创建变量item用于描述玩家的选项。
我们设定当item为0时，表示光标停留在在游戏开始的选项，
当item为1时，表示光标停在排行榜选项
当item为2时，表示光标停在退出游戏选项，

### 重写：keyPressed

光标的移动通过键盘事件触发，将菜单窗体实现KeyListener 键盘监听接口。
重写接口方法，在构造方法中完成键盘监听器的注册
调用this.addKeyListener方法，注册窗体的键盘监听事件
监听器设置为this，表示键盘事件触发以后，调用本窗体中的键盘事件方法。

在键盘的按下事件中得到键盘码
用变量code接收
判断code是否为向下件。如果满足，将item自增，不过，如果玩家一直按向下键，那么光标可能超出屏幕。
我们设定当光标在最后选项时，在按一下向下键，那么光标停留在第一个选项。
判断如果item大于2，将item归为零，
在判断键盘码code是否为向上见。
如果玩家按下向上键，将item自减
item小于零时，将item赋值为2
这样，当光标指向第一个选项时，玩家在按一下向上键，光标移动到最后的选项。
当item选项发生变化时，光标图片标签，cursorLabel的位置需要发生变化，
让光标图片停留在不同的选项上，将cursorLabel变量设置为游戏菜单窗体的属性，便于在键盘事件中访问。

调用cursorLabel的setLocation方法，设置光标图片的位置，x坐标固定为90，Y坐标为320 + item*100，320是第一个选项的位置

测试一下。
可以看到通过键盘已经能够控制光标的移动。
当玩家按下回车键以后，执行光标所在选项的功能。

### 方法：option ---- MenuFrame

创建option方法，完成玩家按下回车键后执行的业务操作。

执行光标对应的业务操作

在键盘按下事件中，继续判断code是否为回车键。
如果为回车键，调用option办法完成业务操作的执行。
在option方法中判断item选项，
如果为零，表示玩家需要执行开始游戏选项。
卸载当前窗体，进入游戏主窗体
如果item为1，表示玩家要执行排行榜选项。
向控制台输出排行榜。排行榜业务，我们在后面实现
如果item为2，表示玩家要执行结束游戏的选项，调用System.exit(）方法，传入零表示正常结束程序。

### 重写：keyPressed ----  SuccessFrame

打开SuccessFrame通关窗体类。
在玩家通关后，设定按下Esc键回到菜单窗体的业务，
这样，玩家可以继续选择执行菜单窗体中的选项

将SuccessFrame实现键盘监听接口。
重写接口方法。
在构造方法中完成键盘事件的注册
调用窗体addKeyListener方法，监听器设置为this，表示键盘事件由当前窗体类响应。

在键盘按下事件中获得键盘码，用变量code接收，判断code是否为Esc键
如果满足，将线程运行变量isRun设置为false，停止线程运行，在卸载当前窗体，产生游戏菜单窗体对象。

### 重写：keyPressed ----  LoseFrame

LoseFrame通关失败窗体也一样，在按一下ESC键后回到游戏菜单窗体，实现方式和通关窗体一样，大家自行实现。

测试一下。
进入游戏菜单窗体，
通过上下键移动光标
在光标移动到排行榜选项时回车，在控制台打印了排行榜。
在光标移动到结束游戏时，程序结束。
重新运行，在光标移动到开始游戏选项时，回车，进入游戏主窗体，
将BOSS打死。进入了通关窗体，按下Esc键，回到了游戏主窗体。
这一讲，我们完成了游戏菜单窗体的实现，

问题：开始游戏后直接进入通关画面？

不过我们现在按下开始游戏选项。可以看到直接进入通关画面，
大家思考一下，原因是什么呢？又如何解决呢？

# 第40章、游戏信息初始化

大家好在上一讲中，我们完成了游戏菜单的实现，
不过当玩家在通关和通过失败时，再回到游戏菜单窗体，按一下开始选项。这时就会直接进入通关窗体或通关失败窗体，

### 问题：开始游戏后直接进入通关画面？

这个原因是什么呢？
原因是在游戏主窗体中，定义的线程是否运行的变量isRun是静态变量，
静态变量只会在类加载时初始化一次，不会在对象产生时初始化，
这就意味着在GameStartFrame种，新对象产生时，不会对静态变量重新赋值，
无论通关成功和失败，静态变量isRun都会被赋值为假，
这样在执行游戏时isRUn变量因为值为假，
所以就会直接结束游戏进入通关或通关失败窗体。
我们来试一下。

### 问题：静态变量的特性

新建test类。包名书写为test
在创建一个Dog类。定义年龄age属性，再定义静态变量X，初始化为一。
在test的main方法中，创建Dog对象，用变量dog1接收。
将dog1的age属性赋值为二，将dog1的X静态变量赋值为三，打印dog1的age属性。在打印dog1的X静态变量，打印横线。

在创建Dog对象，用变量dog2接收。打印dog2的age属性以及X静态变量。
运行一下。

可以看到dog1的age'属性为2，静态变量X为3，
创建新对象以后，dog2的age属性重新初始化为零，但静态变量x的值还是3，
所以静态变量是独立在对象之外的变量，
只在类加载时初始化一次，不会随着对象产生而重新初始化，也不会随的对象销毁而销毁。

属性是对象的组成部分，包含在对象之中。
随对象产生而产生，随对象销毁销毁。

大家需要掌握静态变量和属性区别，在正确的时候使用这两种变量，
由于静态变量不会因为产生新对象而初始化，所以我们要让玩家能重新运行，需要将一些静态变量完成初始化。

### 方法：init --- GameStartFrame

游戏重新开始，各个属性重新初始化

打开GameStartFrame类。
创建初始化方法INIT，完成游戏主窗体静态变量的初始化。
在构造方法中，调用INIT的方法完成游戏信息的初始化。
在INIT的方法中，将静态变量isRun设置为真，让线程恢复运行，
将静态变量girl重新引用新的女孩对象。

调用角色集合roleList的 clear（） 方法，清空角色集合。

将玩家得分score初始化为零。
将女孩的的生命数girlNumber重新赋值为三。
将游戏是否通关变量isPass 重新赋值为false。
至于各个图片，图片的加载可以不用再进行，在玩儿一次游戏时，可以直接使用

### 属性：isInit  ----  InitImage

在InitImage类中，
创建静态变量isInit ，赋值为假，表示角色图片是否已经加载。
在GameStartFrame构造方法中，判断isInit是否为假。
如果为假，那么完成角色图片的加载和初始化，然后将isInit赋值为真。
这样可以让图片初始化方法只执行一次  ，避免重复加载减少流操作

### 方法：init ----  GameMap

地图属性初始化

打开地图类。
地图中的坐标mapx以及地图是否滚动的变量isRoll都需要完成初始化，

在地图类中创建静态方法INIT，完成地图信息的初始化。
将mapx重新赋值为零让地图回到开始的位置，将引入地图是否滚动的变量赋值为真，让地图恢复滚动。

### 方法：init ----  CreateEnemy

怪物属性初始化

打开产生怪物类CreatEnemy，
产生机器狗和灯怪的计数器变量需要初始化，是否产生飞蛾也需要初始化。

创建静态方法INIT，用于初始化产生怪物信息。
将dogcount，产生机器狗计数器的变量归零。
将lightcount，产生灯怪的计数器变量归零，
将isCreatMoth，是否产生飞蛾的变量赋值为真。

### 方法：init --- GameStartFrame

在游戏窗体完成地图属性、怪物属性的初始化

打开GameStartFrame，
在init（）的方法中，调用地图类的初始化方法。完成地图信息的初始化，
在调用产生怪物类的初始化方法。完成产生怪物信息的初始化。

运行一下。
将boss打死。
进入游戏通关窗体，按下esc键，回到游戏菜单窗体，选择开始游戏。
重新进入游戏。可以看到，游戏又重头开始。游戏初始化完成

这一讲我们完成的游戏信息的初始化，大家多理解静态变量和属性的区别，
下一讲我们完成游戏的排行榜。

# 第41章、排行榜（1）

大家好，在上一讲中，我们完成游戏信息的初始化
这一讲我们完成游戏的排行榜，排行榜主要是显示玩家的得分，将玩家分数最高的前五位在窗体中显示出来，以刺激玩家打出高分数。
显然排行榜需要做成单独的窗体，显示玩家分数信息
排行榜信息需要在玩家打出高分时保存起来，我们用文本文件来保存
在窗体加载时读取文件信息在窗体中显示。
很显然，这需要用到IO流操作，
IO流，一共有三个步骤，一、创建流，二、操作流中的数据，三、关闭流。

### 新建类：SortFrame

我们先新建排行榜窗体，SortFrame。

### 操作：option -- MenuFrame

打开游戏菜单窗体，MenuFrame。
在option方法中，当item为1时，卸载当前菜单窗体，产生排行榜窗体对象。

回到SortFrame，将SortFrame继承JFrame，

### 构造方法：SortFrame

书写构造方法，完成窗体信息的初始化

调用setSize方法设置窗口大小，窗体大小设置为950*700,
设置窗体可见程度。
设置窗体关闭后程序结束
设置窗体大小不能改变
设置窗体居中显示。

### 文件：sort.txt

排行榜信存储文档

现在我们需要对排行榜信息进行读取，
在data目录下，新建文本文件。
sort.txt, 用于保存排行榜信息
再sort.txt中，我们先书写一些玩家的得分信息
我们定义一行显示一个玩家的得分信息，
玩家姓名和得分之间以空格隔开，分数从高到低书写。

书写完毕后，保存一下，
现在我们完成文件的读取，
文件读取是IO操作，其本质是将文件中的数据转化为类存中的数据，
我们仔细观察一下，每一行都显示一个玩家的得分信息，而在每一行中包含玩家的姓名以及玩家的得分。

我们可以将玩家的得分，封装成一个得分信息类，而姓名和得分就是该类的属性，这样每一行就是一个得分信息对象，而整个文件中的信息就是一个得分信息集合，

### 新建类：PlayerScore

新建得分实体类，PlayerScore，放在sort包中。
创建属性name表示玩家姓名。
创建属性score表示玩家的得分。
生成set/get方法。重写toString方法。

### 新建类：FilePress

再新建一个类。FilePress，完成对排行榜文件的操作。

### 方法：readFile

新建readFile方法，读取文件信息，返回类型书写为List集合，
泛型书写为PlayerScore 玩家得分类型。

再readFile方法中，创建List集合。
变量名书写scoreList。

返回scoreList。

由于我们读取的是文本文件，所以可以采用字符流来实现
创建Reader类型的变量r，初始化与空，
在创建BufferedReader变量，变量名定义为br，初始化为空，BufferedReader支持行读取，可以更有效的读取文本数据。
将r变量实例化为FileReader对象
传入排行榜信息文件路径，捕获异常。
再将br变量实例化，传入读取字符流对象r
书写finally，完成流的关闭
先关闭BufferedReader，捕获异常
在关闭r读取字符流，

### 问题：框架搭好填内容

大家需要注意写代码，不要从上往下写，而是把框架搭好以后再去填类容。

### 操作：遍历集合

创建String变量str，初始化为空，
用于保存每一行读取的字符串
书写while循环，循环条件书写为br.readLine()，
对文件进行行读取，用字符串变量str接收
当str不等于空时，表示文件中还有数据，继续循环
当str为空时，表示文件读取完毕，从而退出循环
循环变量str字符串中，包含玩家的姓名以及得分两个信息。

在循环体中，创建PlayerScore对象，用变量P接收。
将str字符串调用split的方法，以空格拆分成字符串数组。
用变量array接收
将p对象的name属性设置为array的第一个元素
将p对象的score属性设置为array的第二个元素。由于score属性为整型，将array的第二个元素转化为int类型。

这样，每一行的信息就封装成了一个得分对象。
将玩家得分对象加入scoreList集合。
这样，整个文件信息就变成了类存中的一个集合对象信息。

测试一下，
书写main方法。
产生FilePress对象。
打印RreadFile方法返回的值，运行一下。
可以看到全部玩家的得分信息显示出来，

### 属性：sortList

玩家信息在排行榜窗体中的显示

打开SortFrame排行榜窗体。
新建集合对象，变量名命名为sortList。表示玩家得分集合。

### 问题：排行榜信息读取，且只读一次

为了减少流操作，排行榜信息只读取一次，
没有必要每次进入排行榜窗体都需要反复读取文件。
那么，什么操作只进行一次呢？
静态代码块只在类加载时执行一次。
书写静态代码块。创建FilePress属性。属性名设置为f，
由于静态块只能直接访问静态变量不能访问属性，所以将f变量设置为静态变量。
将f变量实例化。
同时，将玩家得分集合sortList也设置为静态变量
调用f.readFile方法读取文件信息，得到玩家得分集合，并完成对sotList的赋值

这一讲我们完成了排行榜文件的读取
大家思考一下，在排行榜窗体中，我们有大量的标签需要显示，这些标签的代码能不能重用起来？

# 第42章、排行榜（2）

 上一讲我们完成排行榜文件的读取
这一讲我们完成排行榜信息的显示，

### 问题：排行榜窗体的组成

我们现在看一下排行榜窗体的组成，
排行榜窗体中没有动画，可以使用标签组件显示排行榜信息。
先设置背景图片标签，然后显示排行榜文本标签，接着将文件中的玩家得分 以文本标签的方式 显示在窗体中。

### 构造方法：SortFrame

排行榜信息的显示（开闭原则）

在显示窗体之前设置布局管理器为绝对布局。
先创建背景图片标签，完成背景的显示。
背景图片路径“image/sort.png”
创建JLabel标签对象，用变量backImageLabel接收。
传入ImageIcon图片对象。
传入图片路径。
设置标签的位置和大小。标签的位置设置为0到-30。标签的大小设置为950*700。
将标签对象加入窗体。

书写main方法，产生排行榜窗体对象。
运行一下。
可以看到背景图片显示出来。

### 问题：（开闭原则）创建标签的GUI组件对象

在创建标签的GUI组件对象时，如果采用绝对布局，那么需要三个步骤，
第一步创建GUI组件对象，
第二步设置GUI组件对象的位置和大小，
第三步，将GUI组件对象加入容器。
这些步骤很繁琐。在排行榜中，我们有大量的标签，需要显示。
为了重用代码，我们先运用开闭原则，对可以重用的代码进行抽取。



### 新建类：TextLabel

新建TextLabel文本标签类，包名书写为 com.javaGame.component。
将TestLabel继承JLabel标签组件，

### 构造方法：TextLabel（依赖倒置原则）

书写构造方法。
对于文本标签，我们首先需要设置标签的文字，调用setText方法设置标签的文本，文本信息应该传递过来，
设置形参变量info表示标签的文字信息。
然后需要设置标签的位置和大小调用setBounds方法，设置标签的位置和大小，每个标签位置都不一样，所以位置信息应该传递过来。
定义形参变量X和Y，表示标签所在的坐标。大小书写为200*30，设置标签的字体。
调用setFont方法传入字体对象，字体设置为黑体，类型设置为粗体，大小设置为30，
设置标签的前景色，设置为蓝色，然后需要将标签加入窗体，
加入窗体为排行榜窗体SortFrame，
我们定义SortFrame形参变量，形参名命名为frame
将当前标签对象加入SortFrame

问题：思考将SortFrame替换为JFrame

大家思考一下，这样定义好不好的。对了，这样定义并不好
为什么呢，因为SortFrame是一个具体的窗体类。
如果这样定义，就意味着该标签组件只能加入SortFrame窗体类，不能加入别的窗体， 应用范围相当窄，
按照依赖倒置原则，我们应该面向抽象编程，将SortFrame具体的窗体类更改为JFrame
这样，凡是JFrame窗体的子类对象都可以传递过来
也就意味着该标签可以加入任何窗体，增加代码的通用性和灵活性，扩大我们自定义标签组件的应用范围。

### 问题：面向抽象编程

这样，我们自己定义的四个排行榜窗体的标签类创建完成了。
大家多理解下，掌握其中抽象和工作的思想。
事实上，很多公司都有自己的API，大多是在基础的API和框架中根据自己公司需要自己定义的。

### 构造方法：SortFrame

创建排行榜标签

打开排行榜窗体类，首先创建标签组件，显示排行榜三个字作为标题 
创建TextLabel对象，变量名设置为titleLabel。
文字书写为排行榜，为了美观，字与字之间加几个空格。坐标设置为350*100。加入了窗体书写为this当前窗体，表示将标签加入当前窗体。
标签文字，我们定义为红色。另外，标题文字可以设置的大一些。
设置标签的字体。设置字体为华文行楷，粗体，字体大小设置为50
设置标签大小，将标签大小设置为260*50。

运行一下。
可以看到，排行榜标签显示出来。
现在，显示排行榜信息，排行榜信息来自得分集合。

### 方法：showScore

排行榜信息显示（自定义标签的封装）

定义方法showScore，完成排行榜信息的显示。
在构造方法中，调用showScore方法。
在showScore方法中，遍历得分集合sortList。
在循环体中取出得分对象，用变量P接收。
创建排名标签，新建TextLabel对象。

X坐标书写为100，每个玩家信息的Y坐标都不同，
我们定义每个玩家信息的y坐标之间相差80像素。
定义变量Y赋值为 180加上i*80，再排名标签中传入Y变量，加入的容器设置this当前窗体对象

创建玩家姓名标签，新建TextLabel 对象，文字书写p对象的name熟悉，X坐标书写为350，Y坐标传入Y变量，加入的容器定义为this当前窗体对象

创建玩家得分标签，新建TextLabel对象，文字书写为p对象Score属性，不过Score属性是int类型，所以需要转化为字符串类型，调用String的 valueOf方法将玩家得分传入该方法，X坐标书写为600，Y坐标传入y变量，加入的容器书写为this当前窗体对象

运行一下。
可以看到，排行榜窗体中显示的sort.txt 文档中的排行榜信息，
这一讲我完成排行榜信息显示，大家多理解自定义标签的封装，
大家思考一下，在玩家打出高分时，如何对文件的得分进行保存呢。

# 第43章、排行榜信息的添加

我们完成了排行榜信息的显示，这一讲我们完成玩家得分信息的添加

### 在玩家打出高分时如何对玩家得分进行保存？

我们先得看一下保存玩家得分信息的流程。
首先我们需要知道排行榜信息的最低分，只有玩家打怪得分比排行榜信息的最低分更高，
才有必要进行玩家得分信息的添加。
其次，将玩家信息添加至得分集合之后，需要按玩家的得分降序排列，最后需要将前五名的信息重新写入排行榜文件

### 写文件的方法

打开FilePress排行榜信息处理类。
创建一个writeFile方法，用于保存玩家得分信息
定义PlayerScore，形参名定义为p，表示玩家得分信息对象
再定义形参List集合，形参名定义为sortList，表示现有排行榜集合。

在writeFile方法中，先将p添加自玩家得分集合，然后对最新玩家得分进行排序，
调用工具类Collections的 sort方法，传入sortList集合，表示对该集合进行排序，
第二个参数。我们定义为new Comparator接口，用于定义排序规则。

### 排序规则（匿名类部类）

我们书写匿名类部类。泛型书写为PlayerScore，玩家得分信息类
重写接口方法。
在compare方法中定义排序规则，
直接返回第二个元素的得分属性减去第一个元素的得分属性。
这样，当第二个元素得分大于第一个元素得分时，返回正值。
第二个元素得分小于第一个元素时，返回负值
、相等，返回零
这样就对集合中的元素按得分进行了降序排列。

现在将集合的前五个元素写入排行榜文件。
将sortList移除最后一个元素。

新建写入字符流 Writer，变量名设置为w，初始化为空。
将w实例化为FileWriter对象，写入文件路径。
捕获异常。
书写finally语句块完成流的关闭。

遍历sortList集合，循环变量设置为PlayerScore类型，变量名设置为ps。
调用w的write方法，像文件写入信息
先写入ps的name属性，表示玩家姓名，在连接几个空格，在连接ps的得分属性，然后在连接换行符，
每个玩家信息都占1行，每一行由玩家的名字和玩家的得分组成。
这样，写入文件信息的结构和读取文件信息时的结构一致

### 排行榜集合最低分，getLowest方法

打开排行榜窗体类，创建静态方法getLowest。返回类型书写为整型，
返回排行榜集合的最低分。
在方法中，先得到sortList集合中的最后一个元素。
然后再返回最后一个元素的得分。

### 添加玩家得分信息，addScore方法

在创建静态方法addScore，用于添加玩家的得分信息，
形参设置PlayerScore对象，变量名设置为p。
在方法中调用文件处理类对象f.writeFile方法，完成玩家得分信息添加，
传入形参p，最新玩家得分，在传入sortList，表示现有的排行榜集合

### 玩家是否能够进入排行榜

打开GameStartFrame，游戏主窗体类，
在线程的run方法中，当游戏结束时判断当前玩家的得分变量score是否大于排行榜的最后一位得分。
如果条件满足，表示玩家的得分可以进入排行榜，那么弹出对话框。
要求玩家输入自己的大名。用变量PlayerName接收。
将玩家的姓名和当前玩家得分封装成PlayerScored对下个。
创建PlayerScore对象，变量名设置为P。
设置玩家得分对象的姓名。传入PlayerName。
在封装玩家的得分。
将玩家得分封装为PlayerScore的分数属性，
调用SortFrame中的addScore方法
传入玩家最新得分信息对象
完成得分信息的添加。

测试一下。打死BOSS。
弹出对话框，输入大名，太上老君。
进入了通关窗体，按一下Esc键。
回到菜单窗体，进入排行榜，可以看到太上老君已经再排行榜中

好，这一讲，我们完整地排行榜信息的添加下一讲我们完成游戏音乐的播放。

# 第44章、游戏音乐

大家好在上一讲中，我们完成了排行榜信息添加，这一讲我们完成游戏音乐的播放

游戏音乐可以提升玩家玩游戏的激情，可以提升玩家的游戏感受，是游戏中不可缺少的一部分，游戏音乐的播放。我们采用Jlayer来实现。

### 问题：JLayer包中的player类有什么用

JLayer是Java播放mp3音乐所需要的架包，支持多种音频格式播放
这一讲，我们讲解如何利用Jlayer播放音频，在JLayer包中提供的Player类，用以音乐的播放。
该类提供了一个构造方法，需要传入音频的字节流。
为了提高效率，建议采用BufferedInputStream缓冲区的字节流，

在Player类中提供了play方法，播放构造方法中传入的音频字节流。
另外还提供了close方法用于结束音乐播放并关闭音频流。

### 问题：游戏线程之外，开启音频线程

音乐播放需要和动画同步进行，所以应该在游戏动画线程之外，再开启音频线程。
在游戏中，音乐播放分为两种，循环播放音乐和播放一次音乐，

### 问题：二次封装

其中，循环播放音乐适合游戏的背景音乐，在播放完毕后，需要再次播放，避免游戏进行中音乐的缺失，
播放一次音乐适合音效，比如见到道具的声音、爆炸声等等。
为了更好的在游戏项目中进行音乐的播放。我们最好将JLayer中的API进行二次封装，以适合我们的需要。

### 新建类：MusicUtil

将JLayer架包导入游戏项目。
在util包中新建播放音乐的工具类MusicUtil。

### 接口：Runnable

由于需要开启音频线程，将MusicUtil类实现Runnable线程接口。
重写接口方法。

新建Player属性。属性名设置为p，初始化为空，用于音乐的播放。
新建属性filePath，用于描述音频文件的路径。
新建属性isLoop，用于描述是否循环播放音乐。

### 构造方法：MusicUtil

创建构造方法，用于音乐播放的初始化，定义形参filePath，表示播放音频文件的路径，定义形参isLoop，表示是否循环播放音乐，在构造方法中完成filePath属性以及isLoop属性的初始化。

创建Thread线程对象，用变量thread接收，传入实参this，表示线程启动后，执行当前类的run方法，
调用start（）方法启动线程。

### 重写：run ----  MusicUtil

在run方法中书写播放音乐的操作，很显然循环播放音乐需要书写循环语句，而播放一次音乐无需书写循环，
无论是循环播放音乐，还是只播放一次音乐音乐，播放至少进行一次，
那么，这应该如何实现呢？
对了，使用do...while() 语句，do....while语句中循环体至少执行一次，可以满足我们的需要，
在run方法中书写do....while循环，循环条件书写为isLoop，表示如果需要循环播放，那么将isLoop初始化为真，
如果只播放一次，就将isLoop初始化为假，在循环体中先创建音频字节流，

创建BufferedInputStream缓冲区字节流对象，变量名书写为buffer。
传入文件字节流对象，传输路径filePath，捕获异常。
将属性p实例化，传入buffer，缓冲区字节流，
调用p.play 完成音乐的播放。

### 方法：stopMusic

在创建停止音乐播放的方法stopMusic，
调用p.close() 方法停止音乐播放，并关闭音频流，
再将isLoop循环条件设置为假，终止循环。

书写mian方法，创建MusicUtil对象，传入音乐播放的路径。
这是捡到道具的音乐，
传入假，表示只播放一次音乐
运行一下。
在传入真。运行一下。可以听到循环播放的音乐，

### 操作：MusicUtil ---  GameStartFrame

在游戏窗体中应用音乐播放工具类

打开GameStartFrame游戏主窗体类，创建MusicUtil对象，变量名设置为music。

传入文件路径，传入真。表示循环播放音乐。
游戏背景音乐，应该在游戏结束时停止。
在run方法的循环结束以后。调用music的stopMusic方法停止音乐播放

### 操作：MusicUtil ---  SuccessFrame

在通关窗体中应用音乐播放工具类

打开通关窗体类，创建MusicUtil对象，变量名设置为music。
传入文件路径。传入假。表示只播放一次音乐。
音乐应该在按下esc键后停止播放。

在键盘事件中，当用户按下esc键后，调用music的stopMusic方法停止音乐播放

### 操作：MusicUtil  ---- MenuFrame

在菜单窗体中应用音乐播放工具类

打开MenuFrame，游戏菜单窗体类，创建MusicUtil对象，变量名设置music。
传入文件路径，传入假，表示只播放一次音乐。
音乐应该在玩家按一下回车键以后执行具体业务操作时停止。

在option方法中，调用music的stopMusic方法停止音乐播放

### 操作：MusicUtil ----------- Prop

在道具类中实现音乐播放工具类

打开角色类中的道具类。
音乐应该在道具和女孩碰撞时播放
这是音效文件，只播放一次
当道具和玩家相碰时，创建MusicUtil对象，用变量music接收。传入文件路径。传输假，表示只播放一次音乐，

排行榜窗体，游戏通关失败窗体，还有一些音效的播放，大家可以自己添加。

进入游戏菜单窗体，可以听到音乐响起。
选择开始游戏，进入游戏主窗体。菜单窗体音乐停止，响起游戏背景音乐。

减到道具后响起了捡到这个音效，
打死boss后进入通关窗体，游戏背景音乐停止，播放通关音乐。
按一下Esc键后回到游戏菜单窗体，这时通关音乐停止，播放菜单窗体音乐。

JAVA游戏到此为止全部结束，大家多掌握游戏项目框架的搭建，多理解设计原则的使用，
事实上在游戏框架搭建完成以后，具体角色业务的实现，主要靠算法完成

# 总结

框架无法搭建  /  框架理不清，

就拿宠物这个业务来说

算法也不会写

### 项目要求

2.积累完成项目的过程中常见的bug的调试

3.捋顺思路,强化逻辑

4.遵守编码的规范,标识符的命名规范等

5.在类前,方法前,方法类具体逻辑的实现步骤等添加必要的注释

### 项目思考

1. 为什么知识听得懂，到项目时就听不懂了?


2. 为什么项目听得懂，写的时候就不知道从何入手了?


3. 如果时间紧张,项目没有练习完,学习后面知识会不会有影响?


4. 如何才能使得项目掌握的比较好?


5. 基础掌握到什么程度，算是合格的? 优秀的?


6. 要不要敲得很熟? 
   每天花很多时间复习对不对？


7. 现在蒙，是不是相较于以后的知识来讲，还只是冰山一角？


8. 是不是现在不够努力?

9. 怎么衡量一个好的程序员?



